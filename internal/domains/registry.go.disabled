// Package domains provides the domain registry for accessing all domains
// and coordinating cross-domain operations while maintaining separation.
package domains

import (
	"fmt"

	"lerian-mcp-memory/internal/domains/memory"
	"lerian-mcp-memory/internal/domains/system"
	"lerian-mcp-memory/internal/domains/task"
	"lerian-mcp-memory/internal/storage"
)

// Registry implements the DomainRegistry interface
// This is the main entry point for all domain operations
type Registry struct {
	memoryDomain MemoryDomain
	taskDomain   TaskDomain
	systemDomain SystemDomain
	coordinator  DomainCoordinator
}

// RegistryConfig represents configuration for the domain registry
type RegistryConfig struct {
	MemoryConfig      *memory.Config     `json:"memory_config,omitempty"`
	TaskConfig        *task.Config       `json:"task_config,omitempty"`
	SystemConfig      *system.Config     `json:"system_config,omitempty"`
	CoordinatorConfig *CoordinatorConfig `json:"coordinator_config,omitempty"`
	EnableCrossDomain bool               `json:"enable_cross_domain"`
}

// DefaultRegistryConfig returns default configuration for domain registry
func DefaultRegistryConfig() *RegistryConfig {
	return &RegistryConfig{
		MemoryConfig:      memory.DefaultConfig(),
		TaskConfig:        task.DefaultConfig(),
		SystemConfig:      system.DefaultConfig(),
		CoordinatorConfig: DefaultCoordinatorConfig(),
		EnableCrossDomain: true,
	}
}

// NewRegistry creates a new domain registry with all domains configured
func NewRegistry(
	// Storage interfaces
	contentStore storage.ContentStore,
	searchStore storage.SearchStore,
	analysisStore storage.AnalysisStore,
	relationshipStore storage.RelationshipStore,

	// Task domain dependencies
	taskStore task.TaskStore,
	workflowEngine task.WorkflowEngine,
	templateEngine task.TemplateEngine,
	metricsCollector task.MetricsCollector,

	// System domain dependencies
	healthMonitor system.HealthMonitor,
	dataManager system.DataManager,
	sessionManager system.SessionManager,
	citationService system.CitationService,

	// Configuration
	config *RegistryConfig,
) (*Registry, error) {
	if config == nil {
		config = DefaultRegistryConfig()
	}

	// Create memory domain
	memoryDomain := memory.NewDomain(
		contentStore,
		searchStore,
		analysisStore,
		relationshipStore,
		config.MemoryConfig,
	)

	// Create task domain
	taskDomain := task.NewDomain(
		taskStore,
		workflowEngine,
		templateEngine,
		metricsCollector,
		config.TaskConfig,
	)

	// Create system domain
	systemDomain := system.NewDomain(
		healthMonitor,
		dataManager,
		sessionManager,
		citationService,
		config.SystemConfig,
	)

	// Create coordinator for cross-domain operations
	var coordinator DomainCoordinator
	if config.EnableCrossDomain {
		coordinator = NewCoordinator(
			memoryDomain,
			taskDomain,
			systemDomain,
			config.CoordinatorConfig,
		)
	}

	return &Registry{
		memoryDomain: memoryDomain,
		taskDomain:   taskDomain,
		systemDomain: systemDomain,
		coordinator:  coordinator,
	}, nil
}

// Memory returns the memory domain for content and knowledge operations
func (r *Registry) Memory() MemoryDomain {
	return r.memoryDomain
}

// Task returns the task domain for task management operations
func (r *Registry) Task() TaskDomain {
	return r.taskDomain
}

// System returns the system domain for administrative operations
func (r *Registry) System() SystemDomain {
	return r.systemDomain
}

// Coordinator returns the domain coordinator for cross-domain operations
func (r *Registry) Coordinator() DomainCoordinator {
	if r.coordinator == nil {
		panic("cross-domain operations are disabled")
	}
	return r.coordinator
}

// Validate checks that all domains are properly initialized
func (r *Registry) Validate() error {
	if r.memoryDomain == nil {
		return fmt.Errorf("memory domain is not initialized")
	}

	if r.taskDomain == nil {
		return fmt.Errorf("task domain is not initialized")
	}

	if r.systemDomain == nil {
		return fmt.Errorf("system domain is not initialized")
	}

	// Coordinator is optional based on configuration

	return nil
}

// GetDomainInfo returns information about available domains
func (r *Registry) GetDomainInfo() map[string]interface{} {
	info := map[string]interface{}{
		"domains": map[string]interface{}{
			"memory": map[string]interface{}{
				"description": "Content storage, search, and knowledge management",
				"available":   r.memoryDomain != nil,
			},
			"task": map[string]interface{}{
				"description": "Task management, workflows, and productivity features",
				"available":   r.taskDomain != nil,
			},
			"system": map[string]interface{}{
				"description": "Administrative operations and system management",
				"available":   r.systemDomain != nil,
			},
		},
		"cross_domain": map[string]interface{}{
			"description": "Cross-domain operations and orchestration",
			"available":   r.coordinator != nil,
		},
	}

	return info
}

// Shutdown gracefully shuts down all domains
func (r *Registry) Shutdown() error {
	// Domains don't currently have shutdown methods
	// This would be implemented if needed for cleanup
	return nil
}
