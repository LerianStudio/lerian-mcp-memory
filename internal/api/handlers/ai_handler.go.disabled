// Package handlers provides HTTP request handlers for AI services.
package handlers

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/go-chi/chi/v5"

	"lerian-mcp-memory/internal/ai"
	"lerian-mcp-memory/internal/api/response"
)

// AIHandler handles AI service requests
type AIHandler struct {
	aiService *ai.Service
}

// NewAIHandler creates a new AI handler
func NewAIHandler(aiService *ai.Service) *AIHandler {
	return &AIHandler{
		aiService: aiService,
	}
}

// GeneratePRD handles PRD generation requests
func (h *AIHandler) GeneratePRD(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var req PRDGenerationRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		response.WriteError(w, http.StatusBadRequest, "Invalid request body", err.Error())
		return
	}

	// Validate request
	if len(req.UserInputs) == 0 {
		response.WriteError(w, http.StatusBadRequest, "Missing user inputs", "At least one user input is required")
		return
	}

	// Generate PRD using AI service
	prdResp, err := h.aiService.GeneratePRD(ctx, &ai.PRDRequest{
		UserInputs:  req.UserInputs,
		Repository:  req.Repository,
		ProjectType: req.ProjectType,
		Preferences: convertUserPreferences(req.Preferences),
		Metadata:    req.Metadata,
	})
	if err != nil {
		response.WriteError(w, http.StatusInternalServerError, "Failed to generate PRD", err.Error())
		return
	}

	// Convert response
	resp := PRDGenerationResponse{
		ID:          prdResp.ID,
		Title:       prdResp.Title,
		Description: prdResp.Description,
		Features:    prdResp.Features,
		UserStories: prdResp.UserStories,
		ModelUsed:   prdResp.ModelUsed,
		GeneratedAt: prdResp.GeneratedAt,
	}

	response.WriteSuccess(w, resp)
}

// GenerateTRD handles TRD generation requests
func (h *AIHandler) GenerateTRD(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var req TRDGenerationRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		response.WriteError(w, http.StatusBadRequest, "Invalid request body", err.Error())
		return
	}

	// Validate request
	if req.PRDID == "" {
		response.WriteError(w, http.StatusBadRequest, "Missing PRD ID", "PRD ID is required")
		return
	}
	if req.PRDContent == "" {
		response.WriteError(w, http.StatusBadRequest, "Missing PRD content", "PRD content is required")
		return
	}

	// Generate TRD using AI service
	trdResp, err := h.aiService.GenerateTRD(ctx, &ai.TRDRequest{
		PRDID:       req.PRDID,
		PRDContent:  req.PRDContent,
		Repository:  req.Repository,
		ProjectType: req.ProjectType,
		Metadata:    req.Metadata,
	})
	if err != nil {
		response.WriteError(w, http.StatusInternalServerError, "Failed to generate TRD", err.Error())
		return
	}

	// Convert response
	resp := TRDGenerationResponse{
		ID:             trdResp.ID,
		PRDID:          trdResp.PRDID,
		Title:          trdResp.Title,
		Architecture:   trdResp.Architecture,
		TechStack:      trdResp.TechStack,
		Requirements:   trdResp.Requirements,
		Implementation: trdResp.Implementation,
		ModelUsed:      trdResp.ModelUsed,
		GeneratedAt:    trdResp.GeneratedAt,
	}

	response.WriteSuccess(w, resp)
}

// GenerateMainTasks handles main task generation requests
func (h *AIHandler) GenerateMainTasks(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var req MainTaskGenerationRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		response.WriteError(w, http.StatusBadRequest, "Invalid request body", err.Error())
		return
	}

	// Validate request
	if req.TRDID == "" {
		response.WriteError(w, http.StatusBadRequest, "Missing TRD ID", "TRD ID is required")
		return
	}
	if req.TRDContent == "" {
		response.WriteError(w, http.StatusBadRequest, "Missing TRD content", "TRD content is required")
		return
	}

	// Generate main tasks using AI service
	tasksResp, err := h.aiService.GenerateMainTasks(ctx, &ai.MainTaskRequest{
		TRDID:      req.TRDID,
		TRDContent: req.TRDContent,
		Repository: req.Repository,
		Metadata:   req.Metadata,
	})
	if err != nil {
		response.WriteError(w, http.StatusInternalServerError, "Failed to generate main tasks", err.Error())
		return
	}

	// Convert response
	resp := MainTaskGenerationResponse{
		Tasks:       convertMainTasks(tasksResp.Tasks),
		ModelUsed:   tasksResp.ModelUsed,
		GeneratedAt: tasksResp.GeneratedAt,
	}

	response.WriteSuccess(w, resp)
}

// GenerateSubTasks handles sub-task generation requests
func (h *AIHandler) GenerateSubTasks(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var req SubTaskGenerationRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		response.WriteError(w, http.StatusBadRequest, "Invalid request body", err.Error())
		return
	}

	// Validate request
	if req.MainTaskID == "" {
		response.WriteError(w, http.StatusBadRequest, "Missing main task ID", "Main task ID is required")
		return
	}
	if req.MainTaskContent == "" {
		response.WriteError(w, http.StatusBadRequest, "Missing main task content", "Main task content is required")
		return
	}

	// Generate sub-tasks using AI service
	subTasksResp, err := h.aiService.GenerateSubTasks(ctx, &ai.SubTaskRequest{
		MainTaskID:      req.MainTaskID,
		MainTaskContent: req.MainTaskContent,
		Repository:      req.Repository,
		Metadata:        req.Metadata,
	})
	if err != nil {
		response.WriteError(w, http.StatusInternalServerError, "Failed to generate sub-tasks", err.Error())
		return
	}

	// Convert response
	resp := SubTaskGenerationResponse{
		Tasks:       convertSubTasks(subTasksResp.Tasks),
		ModelUsed:   subTasksResp.ModelUsed,
		GeneratedAt: subTasksResp.GeneratedAt,
	}

	response.WriteSuccess(w, resp)
}

// AnalyzeContent handles content analysis requests
func (h *AIHandler) AnalyzeContent(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var req ContentAnalysisRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		response.WriteError(w, http.StatusBadRequest, "Invalid request body", err.Error())
		return
	}

	// Validate request
	if req.Content == "" {
		response.WriteError(w, http.StatusBadRequest, "Missing content", "Content is required")
		return
	}

	// Analyze content using AI service
	analysisResp, err := h.aiService.AnalyzeContent(ctx, &ai.ContentAnalysisRequest{
		Content:    req.Content,
		Type:       req.Type,
		Model:      req.Model,
		Context:    req.Context,
		Repository: req.Repository,
	})
	if err != nil {
		response.WriteError(w, http.StatusInternalServerError, "Failed to analyze content", err.Error())
		return
	}

	// Convert response
	resp := ContentAnalysisResponse{
		Summary:     analysisResp.Summary,
		Topics:      analysisResp.Topics,
		Sentiment:   analysisResp.Sentiment,
		Quality:     analysisResp.Quality,
		Suggestions: analysisResp.Suggestions,
		ModelUsed:   analysisResp.ModelUsed,
		ProcessedAt: analysisResp.ProcessedAt,
	}

	response.WriteSuccess(w, resp)
}

// EstimateComplexity handles complexity estimation requests
func (h *AIHandler) EstimateComplexity(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var req map[string]string
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		response.WriteError(w, http.StatusBadRequest, "Invalid request body", err.Error())
		return
	}

	content, ok := req["content"]
	if !ok || content == "" {
		response.WriteError(w, http.StatusBadRequest, "Missing content", "Content is required")
		return
	}

	// Estimate complexity using AI service
	estimate, err := h.aiService.EstimateComplexity(ctx, content)
	if err != nil {
		response.WriteError(w, http.StatusInternalServerError, "Failed to estimate complexity", err.Error())
		return
	}

	response.WriteSuccess(w, estimate)
}

// StartInteractiveSession handles session start requests
func (h *AIHandler) StartInteractiveSession(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var req map[string]string
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		response.WriteError(w, http.StatusBadRequest, "Invalid request body", err.Error())
		return
	}

	docType, ok := req["type"]
	if !ok || docType == "" {
		response.WriteError(w, http.StatusBadRequest, "Missing type", "Document type is required")
		return
	}

	// Start interactive session
	session, err := h.aiService.StartInteractiveSession(ctx, docType)
	if err != nil {
		response.WriteError(w, http.StatusInternalServerError, "Failed to start session", err.Error())
		return
	}

	response.WriteSuccess(w, session)
}

// ContinueSession handles session continuation requests
func (h *AIHandler) ContinueSession(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	sessionID := chi.URLParam(r, "id")
	if sessionID == "" {
		response.WriteError(w, http.StatusBadRequest, "Missing session ID", "Session ID is required")
		return
	}

	var req map[string]string
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		response.WriteError(w, http.StatusBadRequest, "Invalid request body", err.Error())
		return
	}

	userInput := req["input"]

	// Continue session
	sessionResp, err := h.aiService.ContinueSession(ctx, sessionID, userInput)
	if err != nil {
		response.WriteError(w, http.StatusInternalServerError, "Failed to continue session", err.Error())
		return
	}

	response.WriteSuccess(w, sessionResp)
}

// EndSession handles session end requests
func (h *AIHandler) EndSession(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	sessionID := chi.URLParam(r, "id")
	if sessionID == "" {
		response.WriteError(w, http.StatusBadRequest, "Missing session ID", "Session ID is required")
		return
	}

	// End session
	err := h.aiService.EndSession(ctx, sessionID)
	if err != nil {
		response.WriteError(w, http.StatusInternalServerError, "Failed to end session", err.Error())
		return
	}

	response.WriteSuccess(w, map[string]string{
		"message":    "Session ended successfully",
		"session_id": sessionID,
	})
}

// GetAvailableModels handles model listing requests
func (h *AIHandler) GetAvailableModels(w http.ResponseWriter, r *http.Request) {
	models := h.aiService.GetAvailableModels()

	resp := map[string]interface{}{
		"models": models,
		"count":  len(models),
	}

	response.WriteSuccess(w, resp)
}

// Request/Response types for the AI handler

type PRDGenerationRequest struct {
	UserInputs  []string               `json:"user_inputs"`
	Repository  string                 `json:"repository"`
	ProjectType string                 `json:"project_type"`
	Preferences UserPreferences        `json:"preferences"`
	Metadata    map[string]interface{} `json:"metadata"`
	Model       string                 `json:"model,omitempty"`
}

type PRDGenerationResponse struct {
	ID          string    `json:"id"`
	Title       string    `json:"title"`
	Description string    `json:"description"`
	Features    []string  `json:"features"`
	UserStories []string  `json:"user_stories"`
	ModelUsed   string    `json:"model_used"`
	GeneratedAt time.Time `json:"generated_at"`
}

type TRDGenerationRequest struct {
	PRDID       string                 `json:"prd_id"`
	PRDContent  string                 `json:"prd_content"`
	Repository  string                 `json:"repository"`
	ProjectType string                 `json:"project_type"`
	Metadata    map[string]interface{} `json:"metadata"`
	Model       string                 `json:"model,omitempty"`
}

type TRDGenerationResponse struct {
	ID             string    `json:"id"`
	PRDID          string    `json:"prd_id"`
	Title          string    `json:"title"`
	Architecture   string    `json:"architecture"`
	TechStack      []string  `json:"tech_stack"`
	Requirements   []string  `json:"requirements"`
	Implementation []string  `json:"implementation"`
	ModelUsed      string    `json:"model_used"`
	GeneratedAt    time.Time `json:"generated_at"`
}

type MainTaskGenerationRequest struct {
	TRDID      string                 `json:"trd_id"`
	TRDContent string                 `json:"trd_content"`
	Repository string                 `json:"repository"`
	Metadata   map[string]interface{} `json:"metadata"`
	Model      string                 `json:"model,omitempty"`
}

type MainTaskGenerationResponse struct {
	Tasks       []MainTaskResponse `json:"tasks"`
	ModelUsed   string             `json:"model_used"`
	GeneratedAt time.Time          `json:"generated_at"`
}

type MainTaskResponse struct {
	ID               string   `json:"id"`
	Name             string   `json:"name"`
	Description      string   `json:"description"`
	Phase            string   `json:"phase"`
	Duration         string   `json:"duration"`
	AtomicValidation bool     `json:"atomic_validation"`
	Dependencies     []string `json:"dependencies"`
	Content          string   `json:"content"`
}

type SubTaskGenerationRequest struct {
	MainTaskID      string                 `json:"main_task_id"`
	MainTaskContent string                 `json:"main_task_content"`
	Repository      string                 `json:"repository"`
	Metadata        map[string]interface{} `json:"metadata"`
	Model           string                 `json:"model,omitempty"`
}

type SubTaskGenerationResponse struct {
	Tasks       []SubTaskResponse `json:"tasks"`
	ModelUsed   string            `json:"model_used"`
	GeneratedAt time.Time         `json:"generated_at"`
}

type SubTaskResponse struct {
	ID                 string   `json:"id"`
	ParentTaskID       string   `json:"parent_task_id"`
	Name               string   `json:"name"`
	Duration           int      `json:"duration"`
	Type               string   `json:"type"`
	Deliverables       []string `json:"deliverables"`
	AcceptanceCriteria []string `json:"acceptance_criteria"`
	Dependencies       []string `json:"dependencies"`
	Content            string   `json:"content"`
}

type ContentAnalysisRequest struct {
	Content    string                 `json:"content"`
	Type       string                 `json:"type,omitempty"`
	Model      string                 `json:"model,omitempty"`
	Context    map[string]interface{} `json:"context,omitempty"`
	Repository string                 `json:"repository,omitempty"`
}

type ContentAnalysisResponse struct {
	Summary     string    `json:"summary"`
	Topics      []string  `json:"topics"`
	Sentiment   string    `json:"sentiment"`
	Quality     float64   `json:"quality"`
	Suggestions []string  `json:"suggestions"`
	ModelUsed   string    `json:"model_used"`
	ProcessedAt time.Time `json:"processed_at"`
}

type UserPreferences struct {
	PreferredTaskSize   string   `json:"preferred_task_size"`
	PreferredComplexity string   `json:"preferred_complexity"`
	IncludeTests        bool     `json:"include_tests"`
	IncludeDocs         bool     `json:"include_docs"`
	FavoriteTemplates   []string `json:"favorite_templates,omitempty"`
	AvoidPatterns       []string `json:"avoid_patterns,omitempty"`
}

// Helper functions

func convertUserPreferences(prefs UserPreferences) ai.UserPreferences {
	return ai.UserPreferences{
		PreferredTaskSize:   prefs.PreferredTaskSize,
		PreferredComplexity: prefs.PreferredComplexity,
		IncludeTests:        prefs.IncludeTests,
		IncludeDocs:         prefs.IncludeDocs,
		FavoriteTemplates:   prefs.FavoriteTemplates,
		AvoidPatterns:       prefs.AvoidPatterns,
	}
}

func convertMainTasks(tasks []ai.MainTaskResponse) []MainTaskResponse {
	result := make([]MainTaskResponse, len(tasks))
	for i, task := range tasks {
		result[i] = MainTaskResponse{
			ID:               task.ID,
			Name:             task.Name,
			Description:      task.Description,
			Phase:            task.Phase,
			Duration:         task.Duration,
			AtomicValidation: task.AtomicValidation,
			Dependencies:     task.Dependencies,
			Content:          task.Content,
		}
	}
	return result
}

func convertSubTasks(tasks []ai.SubTaskResponse) []SubTaskResponse {
	result := make([]SubTaskResponse, len(tasks))
	for i, task := range tasks {
		result[i] = SubTaskResponse{
			ID:                 task.ID,
			ParentTaskID:       task.ParentTaskID,
			Name:               task.Name,
			Duration:           task.Duration,
			Type:               task.Type,
			Deliverables:       task.Deliverables,
			AcceptanceCriteria: task.AcceptanceCriteria,
			Dependencies:       task.Dependencies,
			Content:            task.Content,
		}
	}
	return result
}