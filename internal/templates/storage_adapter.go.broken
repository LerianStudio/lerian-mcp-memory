// Package templates provides storage adapter for template data persistence
package templates

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"lerian-mcp-memory/internal/storage"
	itypes "lerian-mcp-memory/internal/types"
	"lerian-mcp-memory/pkg/types"
)

// StorageAdapter implements TemplateStorage using the existing vector and content storage
type StorageAdapter struct {
	vectorStore  storage.VectorStore
	contentStore storage.ContentStore
}

// NewStorageAdapter creates a new storage adapter for templates
func NewStorageAdapter(vectorStore storage.VectorStore, contentStore storage.ContentStore) *StorageAdapter {
	return &StorageAdapter{
		vectorStore:  vectorStore,
		contentStore: contentStore,
	}
}

// StoreTemplateUsage stores template usage statistics
func (sa *StorageAdapter) StoreTemplateUsage(ctx context.Context, templateID, projectID string, success bool, metadata map[string]interface{}) error {
	// Create usage record
	usageRecord := map[string]interface{}{
		"template_id": templateID,
		"project_id":  projectID,
		"success":     success,
		"timestamp":   time.Now(),
		"metadata":    metadata,
	}

	// Serialize to JSON
	content, err := json.Marshal(usageRecord)
	if err != nil {
		return fmt.Errorf("failed to serialize usage record: %w", err)
	}

	// Store as content
	contentData := &itypes.Content{
		ID:        fmt.Sprintf("template_usage_%s_%s_%d", templateID, projectID, time.Now().Unix()),
		ProjectID: itypes.ProjectID(projectID),
		Type:      "template_usage",
		Content:   string(content),
		Metadata: map[string]interface{}{
			"template_id": templateID,
			"success":     success,
			"category":    "template_usage",
		},
		CreatedAt: time.Now(),
	}

	return sa.contentStore.Store(ctx, contentData)
}

// GetTemplateUsage retrieves usage statistics for a template
func (sa *StorageAdapter) GetTemplateUsage(ctx context.Context, templateID string) (*TemplateUsageStats, error) {
	// For simplicity, list all chunks and filter manually
	// In a real implementation, we'd use a proper content search
	allChunks, err := sa.vectorStore.ListByRepository(ctx, templateID, 1000, 0)
	if err != nil {
		return nil, fmt.Errorf("failed to list template usage: %w", err)
	}

	if len(allChunks) == 0 {
		// Return empty stats for unused template
		return &TemplateUsageStats{
			TemplateID:      templateID,
			UsageCount:      0,
			SuccessCount:    0,
			FailureCount:    0,
			SuccessRate:     0.0,
			PopularityScore: 0.0,
		}, nil
	}

	// Aggregate usage statistics
	var usageCount, successCount, failureCount int
	var lastUsed time.Time
	var totalDuration int64

	for _, chunk := range allChunks {
		var usageRecord map[string]interface{}
		if err := json.Unmarshal([]byte(chunk.Content), &usageRecord); err != nil {
			continue // Skip invalid records
		}

		usageCount++

		if success, ok := usageRecord["success"].(bool); ok && success {
			successCount++
		} else {
			failureCount++
		}

		// Parse timestamp
		if timestampStr, ok := usageRecord["timestamp"].(string); ok {
			if timestamp, err := time.Parse(time.RFC3339, timestampStr); err == nil {
				if timestamp.After(lastUsed) {
					lastUsed = timestamp
				}
			}
		}

		// Extract duration from metadata
		if metadata, ok := usageRecord["metadata"].(map[string]interface{}); ok {
			if duration, ok := metadata["duration_ms"].(float64); ok {
				totalDuration += int64(duration)
			}
		}
	}

	// Calculate success rate
	var successRate float64
	if usageCount > 0 {
		successRate = float64(successCount) / float64(usageCount)
	}

	// Calculate average time
	var averageTime string
	if successCount > 0 && totalDuration > 0 {
		avgMs := totalDuration / int64(successCount)
		if avgMs < 1000 {
			averageTime = fmt.Sprintf("%dms", avgMs)
		} else if avgMs < 60000 {
			averageTime = fmt.Sprintf("%.1fs", float64(avgMs)/1000)
		} else {
			averageTime = fmt.Sprintf("%.1fm", float64(avgMs)/60000)
		}
	}

	// Calculate popularity score (simple formula based on usage and success rate)
	popularityScore := float64(usageCount) * successRate / 100.0
	if popularityScore > 1.0 {
		popularityScore = 1.0
	}

	stats := &TemplateUsageStats{
		TemplateID:      templateID,
		UsageCount:      usageCount,
		SuccessCount:    successCount,
		FailureCount:    failureCount,
		SuccessRate:     successRate,
		LastUsed:        lastUsed,
		AverageTime:     averageTime,
		PopularityScore: popularityScore,
	}

	return stats, nil
}

// StoreGeneratedTasks stores the tasks generated from a template instantiation
func (sa *StorageAdapter) StoreGeneratedTasks(ctx context.Context, result *TemplateInstantiationResult) error {
	// Store the complete instantiation result
	resultContent, err := json.Marshal(result)
	if err != nil {
		return fmt.Errorf("failed to serialize instantiation result: %w", err)
	}

	// Store instantiation result as content
	contentData := &itypes.Content{
		ID:        fmt.Sprintf("template_instantiation_%s_%s_%d", result.TemplateID, result.ProjectID, result.GeneratedAt.Unix()),
		ProjectID: result.ProjectID,
		SessionID: result.SessionID,
		Type:      "template_instantiation",
		Content:   string(resultContent),
		Metadata: map[string]interface{}{
			"template_id":    result.TemplateID,
			"template_name":  result.TemplateName,
			"task_count":     result.TaskCount,
			"estimated_time": result.EstimatedTime,
			"category":       "template_instantiation",
		},
		CreatedAt: result.GeneratedAt,
	}

	if err := sa.contentStore.Store(ctx, contentData); err != nil {
		return fmt.Errorf("failed to store instantiation result: %w", err)
	}

	// Store individual tasks as separate content items for better searchability
	for _, task := range result.Tasks {
		taskContent, err := json.Marshal(task)
		if err != nil {
			continue // Skip this task if serialization fails
		}

		taskContentData := &itypes.Content{
			ID:        task.ID,
			ProjectID: task.ProjectID,
			SessionID: task.SessionID,
			Type:      "generated_task",
			Content:   string(taskContent),
			Metadata: map[string]interface{}{
				"template_id":      task.TemplateID,
				"task_type":        task.Type,
				"task_priority":    task.Priority,
				"estimated_time":   task.EstimatedTime,
				"dependency_count": len(task.Dependencies),
				"tag_count":        len(task.Tags),
				"category":         "generated_task",
			},
			CreatedAt: task.CreatedAt,
		}

		// Store task content (ignore errors for individual tasks)
		_ = sa.contentStore.Store(ctx, taskContentData)
	}

	return nil
}

// GetGeneratedTasks retrieves tasks generated from templates for a project
func (sa *StorageAdapter) GetGeneratedTasks(ctx context.Context, projectID, templateID string) ([]GeneratedTask, error) {
	// Build search query
	var queryStr string
	filters := map[string]interface{}{
		"type":       "generated_task",
		"project_id": projectID,
	}

	if templateID != "" {
		queryStr = fmt.Sprintf("template_id:%s project_id:%s", templateID, projectID)
		filters["template_id"] = templateID
	} else {
		queryStr = fmt.Sprintf("project_id:%s", projectID)
	}

	query := &storage.SearchQuery{
		Query:   queryStr,
		Filters: filters,
		Limit:   1000, // Get all tasks
	}

	results, err := sa.vectorStore.Search(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("failed to search generated tasks: %w", err)
	}

	var tasks []GeneratedTask
	for _, result := range results.Results {
		var task GeneratedTask
		if err := json.Unmarshal([]byte(result.Content), &task); err != nil {
			continue // Skip invalid task records
		}
		tasks = append(tasks, task)
	}

	return tasks, nil
}

// GetTemplateInstantiations retrieves template instantiation results for a project
func (sa *StorageAdapter) GetTemplateInstantiations(ctx context.Context, projectID string, templateID string) ([]*TemplateInstantiationResult, error) {
	// Build search query
	var queryStr string
	filters := map[string]interface{}{
		"type":       "template_instantiation",
		"project_id": projectID,
	}

	if templateID != "" {
		queryStr = fmt.Sprintf("template_id:%s project_id:%s", templateID, projectID)
		filters["template_id"] = templateID
	} else {
		queryStr = fmt.Sprintf("project_id:%s", projectID)
	}

	query := &storage.SearchQuery{
		Query:   queryStr,
		Filters: filters,
		Limit:   100, // Reasonable limit for instantiations
	}

	results, err := sa.vectorStore.Search(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("failed to search template instantiations: %w", err)
	}

	var instantiations []*TemplateInstantiationResult
	for _, result := range results.Results {
		var instantiation TemplateInstantiationResult
		if err := json.Unmarshal([]byte(result.Content), &instantiation); err != nil {
			continue // Skip invalid instantiation records
		}
		instantiations = append(instantiations, &instantiation)
	}

	return instantiations, nil
}

// CleanupOldUsageRecords removes old usage records to prevent storage bloat
func (sa *StorageAdapter) CleanupOldUsageRecords(ctx context.Context, olderThan time.Duration) error {
	cutoffTime := time.Now().Add(-olderThan)

	// Search for old usage records
	query := &storage.SearchQuery{
		Query: "type:template_usage",
		Filters: map[string]interface{}{
			"type": "template_usage",
		},
		Limit: 10000,
	}

	results, err := sa.vectorStore.Search(ctx, query)
	if err != nil {
		return fmt.Errorf("failed to search for old usage records: %w", err)
	}

	var recordsToDelete []string
	for _, result := range results.Results {
		var usageRecord map[string]interface{}
		if err := json.Unmarshal([]byte(result.Content), &usageRecord); err != nil {
			continue
		}

		// Check timestamp
		if timestampStr, ok := usageRecord["timestamp"].(string); ok {
			if timestamp, err := time.Parse(time.RFC3339, timestampStr); err == nil {
				if timestamp.Before(cutoffTime) {
					recordsToDelete = append(recordsToDelete, result.ID)
				}
			}
		}
	}

	// Delete old records
	for _, id := range recordsToDelete {
		// Note: This assumes the vector store has a delete method
		// Implementation may vary based on actual VectorStore interface
		if deleter, ok := sa.vectorStore.(interface {
			Delete(ctx context.Context, id string) error
		}); ok {
			_ = deleter.Delete(ctx, id) // Ignore individual delete errors
		}
	}

	return nil
}

// GetTemplateMetrics returns aggregated metrics across all templates
func (sa *StorageAdapter) GetTemplateMetrics(ctx context.Context, projectID string) (*TemplateMetrics, error) {
	// Search for all template usage records
	query := &storage.SearchQuery{
		Query: fmt.Sprintf("type:template_usage project_id:%s", projectID),
		Filters: map[string]interface{}{
			"type":       "template_usage",
			"project_id": projectID,
		},
		Limit: 10000,
	}

	results, err := sa.vectorStore.Search(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("failed to search template metrics: %w", err)
	}

	// Aggregate metrics
	templateUsage := make(map[string]int)
	var totalUsage, totalSuccess int
	var firstUsed, lastUsed time.Time

	for _, result := range results.Results {
		var usageRecord map[string]interface{}
		if err := json.Unmarshal([]byte(result.Content), &usageRecord); err != nil {
			continue
		}

		totalUsage++

		if templateID, ok := usageRecord["template_id"].(string); ok {
			templateUsage[templateID]++
		}

		if success, ok := usageRecord["success"].(bool); ok && success {
			totalSuccess++
		}

		if timestampStr, ok := usageRecord["timestamp"].(string); ok {
			if timestamp, err := time.Parse(time.RFC3339, timestampStr); err == nil {
				if firstUsed.IsZero() || timestamp.Before(firstUsed) {
					firstUsed = timestamp
				}
				if timestamp.After(lastUsed) {
					lastUsed = timestamp
				}
			}
		}
	}

	// Find most popular template
	var mostPopularTemplate string
	var maxUsage int
	for templateID, usage := range templateUsage {
		if usage > maxUsage {
			maxUsage = usage
			mostPopularTemplate = templateID
		}
	}

	// Calculate success rate
	var successRate float64
	if totalUsage > 0 {
		successRate = float64(totalSuccess) / float64(totalUsage)
	}

	metrics := &TemplateMetrics{
		ProjectID:              projectID,
		TotalTemplatesUsed:     len(templateUsage),
		TotalUsageCount:        totalUsage,
		TotalSuccessCount:      totalSuccess,
		OverallSuccessRate:     successRate,
		MostPopularTemplate:    mostPopularTemplate,
		FirstUsed:              firstUsed,
		LastUsed:               lastUsed,
		TemplateUsageBreakdown: templateUsage,
		GeneratedAt:            time.Now(),
	}

	return metrics, nil
}

// TemplateMetrics represents aggregated template usage metrics
type TemplateMetrics struct {
	ProjectID              string         `json:"project_id"`
	TotalTemplatesUsed     int            `json:"total_templates_used"`
	TotalUsageCount        int            `json:"total_usage_count"`
	TotalSuccessCount      int            `json:"total_success_count"`
	OverallSuccessRate     float64        `json:"overall_success_rate"`
	MostPopularTemplate    string         `json:"most_popular_template"`
	FirstUsed              time.Time      `json:"first_used"`
	LastUsed               time.Time      `json:"last_used"`
	TemplateUsageBreakdown map[string]int `json:"template_usage_breakdown"`
	GeneratedAt            time.Time      `json:"generated_at"`
}
