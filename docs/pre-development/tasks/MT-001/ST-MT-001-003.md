# ST-MT-001-003: Create Task Service with Business Logic

## Status
- **Status:** ✅ Complete
- **Completion Date:** 2025-01-08
- **Implementation:** Successfully implemented in `cli/internal/domain/services/task_service.go`

## 1. Sub-Task Overview
- **Sub-Task ID:** ST-MT-001-003
- **Sub-Task Name:** Create Task Service with Business Logic
- **Parent Task:** MT-001: CLI Foundation with Local Storage and MCP Integration
- **Estimated Duration:** 4 hours
- **Implementation Type:** Code

## 2. Deliverable Specification
- **Primary Output:** TaskService implementing core business logic
- **Code Location:** `cli/internal/domain/services/task_service.go`
- **Technical Requirements:** Domain service with dependency injection, error handling
- **Interface Definition:** Service methods for task operations with validation

## 3. Implementation Details
- **Step-by-Step Approach:**
  1. Create TaskService struct with injected dependencies
  2. Implement CreateTask with validation and repository detection
  3. Implement ListTasks with filtering and sorting
  4. Implement UpdateTaskStatus with business rules
  5. Implement EditTask with validation
  6. Add repository auto-detection logic
  7. Implement task relationship management
  8. Add session tracking integration

- **Code Examples:**
  ```go
  type TaskService struct {
      storage     ports.Storage
      repository  ports.RepositoryDetector
      validator   *validator.Validate
      logger      *slog.Logger
  }
  
  func NewTaskService(storage ports.Storage, repo ports.RepositoryDetector, logger *slog.Logger) *TaskService {
      return &TaskService{
          storage:    storage,
          repository: repo,
          validator:  validator.New(),
          logger:     logger,
      }
  }
  
  func (s *TaskService) CreateTask(ctx context.Context, content string, options ...TaskOption) (*Task, error) {
      repository, err := s.repository.DetectCurrent()
      if err != nil {
          return nil, fmt.Errorf("failed to detect repository: %w", err)
      }
      
      task, err := NewTask(content, repository)
      if err != nil {
          return nil, fmt.Errorf("invalid task: %w", err)
      }
      
      // Apply options (priority, tags, etc.)
      for _, option := range options {
          option(task)
      }
      
      if err := s.storage.SaveTask(task); err != nil {
          s.logger.Error("failed to save task", 
              slog.String("task_id", task.ID),
              slog.Any("error", err))
          return nil, fmt.Errorf("failed to save task: %w", err)
      }
      
      s.logger.Info("task created",
          slog.String("task_id", task.ID),
          slog.String("repository", repository),
          slog.String("content", content))
      
      return task, nil
  }
  
  type TaskFilters struct {
      Status     *Status
      Priority   *Priority
      Repository string
      Tags       []string
      ParentID   string
  }
  
  func (s *TaskService) ListTasks(ctx context.Context, filters TaskFilters) ([]*Task, error) {
      if filters.Repository == "" {
          repo, err := s.repository.DetectCurrent()
          if err != nil {
              return nil, fmt.Errorf("failed to detect repository: %w", err)
          }
          filters.Repository = repo
      }
      
      tasks, err := s.storage.ListTasks(filters.Repository, filters)
      if err != nil {
          return nil, fmt.Errorf("failed to list tasks: %w", err)
      }
      
      // Apply in-memory filtering for complex criteria
      filtered := make([]*Task, 0, len(tasks))
      for _, task := range tasks {
          if s.matchesFilters(task, filters) {
              filtered = append(filtered, task)
          }
      }
      
      // Sort by priority and creation date
      sort.Slice(filtered, func(i, j int) bool {
          return s.compareTaskPriority(filtered[i], filtered[j])
      })
      
      return filtered, nil
  }
  
  func (s *TaskService) UpdateTaskStatus(ctx context.Context, taskID string, newStatus Status) error {
      task, err := s.storage.GetTask(taskID)
      if err != nil {
          return fmt.Errorf("task not found: %w", err)
      }
      
      if err := s.validateStatusTransition(task.Status, newStatus); err != nil {
          return err
      }
      
      task.Status = newStatus
      task.UpdatedAt = time.Now()
      
      if newStatus == StatusCompleted {
          now := time.Now()
          task.CompletedAt = &now
      }
      
      if err := s.storage.UpdateTask(task); err != nil {
          return fmt.Errorf("failed to update task: %w", err)
      }
      
      s.logger.Info("task status updated",
          slog.String("task_id", taskID),
          slog.String("new_status", string(newStatus)))
      
      return nil
  }
  
  func (s *TaskService) validateStatusTransition(current, new Status) error {
      // Business rules for status transitions
      switch current {
      case StatusCompleted:
          if new != StatusPending {
              return errors.New("completed tasks can only be reopened to pending")
          }
      case StatusCancelled:
          if new != StatusPending {
              return errors.New("cancelled tasks can only be reopened to pending")
          }
      }
      return nil
  }
  
  // Task options pattern for flexible creation
  type TaskOption func(*Task)
  
  func WithPriority(priority Priority) TaskOption {
      return func(t *Task) {
          t.Priority = priority
      }
  }
  
  func WithTags(tags ...string) TaskOption {
      return func(t *Task) {
          t.Tags = tags
      }
  }
  
  func WithEstimatedTime(minutes int) TaskOption {
      return func(t *Task) {
          t.EstimatedMins = minutes
      }
  }
  ```

- **Configuration Changes:** None required
- **Dependencies:** 
  - `github.com/go-playground/validator/v10`
  - `log/slog` (standard library)

## 4. Acceptance Criteria
- **Functional Criteria:**
  - All CRUD operations work correctly with validation
  - Repository auto-detection functions properly
  - Status transitions follow business rules
  - Task filtering and sorting work as expected
  - Error handling provides actionable feedback
  
- **Technical Criteria:**
  - Service layer properly isolated from storage details
  - Dependency injection allows for testing with mocks
  - Logging provides adequate operation visibility
  - Context handling for cancellation and timeouts
  
- **Integration Criteria:**
  - Integrates cleanly with Storage interface
  - Can be used by CLI command handlers
  - Error propagation maintains context
  
- **Test Criteria:**
  - All business logic scenarios tested
  - Error conditions properly handled
  - Mocking enables isolated testing

## 5. Testing Requirements
- **Unit Tests:**
  - Task creation with various options
  - Repository detection and handling
  - Status transition validation
  - Task filtering logic correctness
  - Error handling for invalid inputs
  - Business rule enforcement
  - Logging verification
  - Options pattern functionality

- **Integration Tests:**
  - Service integration with FileStorage
  - Repository detection in various directories
  - End-to-end task lifecycle operations
  
- **Manual Testing:** 
  - Verify business rules in CLI usage
  - Test repository detection accuracy
  
- **Test Data:** Mock storage and repository detector for isolated testing

## 6. Definition of Done
- **Code Complete:** TaskService implements all required operations
- **Tests Passing:** Unit tests achieve ≥90% coverage
- **Documentation Updated:** All public methods documented
- **Integration Verified:** Works with FileStorage and CLI commands
- **Review Approved:** Business logic review completed

## 7. Dependencies and Blockers
- **Required Sub-Tasks:** 
  - ST-MT-001-001 (Task Entity)
  - ST-MT-001-002 (File Storage)
- **External Dependencies:** Validation library, standard logging
- **Environmental Requirements:** Go development environment
- **Potential Blockers:** Complex business rule requirements

## 8. Integration Notes
- **Component Interfaces:** Uses Storage port, provides service for CLI
- **Data Flow:** CLI → TaskService → Storage → Files
- **Error Handling:** Wraps storage errors with business context
- **Configuration Impact:** None - uses injected dependencies