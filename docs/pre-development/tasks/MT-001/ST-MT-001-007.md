# ST-MT-001-007: Create Application Bootstrap and Dependency Injection

## Status
- **Status:** âœ… COMPLETED
- **Completion Date:** 2025-01-09
- **Implementation:** Successfully implemented in `/Users/fredamaral/Repos/lerianstudio/lerian-mcp-memory/cli/internal/di/container.go`
- **Actual Implementation:** Comprehensive dependency injection container with lifecycle management and graceful shutdown
- **Deviations:** Added test container support, enhanced logging configuration, and resource cleanup
- **Next Steps:** None - DI container properly manages all application dependencies

## 1. Sub-Task Overview
- **Sub-Task ID:** ST-MT-001-007
- **Sub-Task Name:** Create Application Bootstrap and Dependency Injection
- **Parent Task:** MT-001: CLI Foundation with Local Storage and MCP Integration
- **Estimated Duration:** 3 hours
- **Implementation Type:** Code

## 2. Deliverable Specification
- **Primary Output:** Main application bootstrap with dependency injection container
- **Code Location:** `cli/cmd/lerian-mcp-memory-cli/main.go` and `cli/internal/di/container.go`
- **Technical Requirements:** Dependency injection, application lifecycle, graceful shutdown
- **Interface Definition:** Application container with all dependencies wired correctly

## 3. Implementation Details
- **Step-by-Step Approach:**
  1. Create dependency injection container
  2. Setup application bootstrap in main.go
  3. Wire all components together (Storage, Service, MCP, Config)
  4. Implement graceful shutdown handling
  5. Add version information and build metadata
  6. Setup logging configuration
  7. Add error handling for startup failures
  8. Create health check for critical dependencies

- **Code Examples:**
  ```go
  // Dependency injection container
  type Container struct {
      Config            *Config
      ConfigManager     ConfigManager
      Logger            *slog.Logger
      Storage           Storage
      MCPClient         MCPClient
      TaskService       *TaskService
      RepositoryDetector RepositoryDetector
  }
  
  func NewContainer() (*Container, error) {
      container := &Container{}
      
      // Initialize logger first
      if err := container.initLogger(); err != nil {
          return nil, fmt.Errorf("failed to initialize logger: %w", err)
      }
      
      // Load configuration
      if err := container.initConfig(); err != nil {
          return nil, fmt.Errorf("failed to initialize config: %w", err)
      }
      
      // Initialize storage
      if err := container.initStorage(); err != nil {
          return nil, fmt.Errorf("failed to initialize storage: %w", err)
      }
      
      // Initialize MCP client
      if err := container.initMCPClient(); err != nil {
          return nil, fmt.Errorf("failed to initialize MCP client: %w", err)
      }
      
      // Initialize repository detector
      if err := container.initRepositoryDetector(); err != nil {
          return nil, fmt.Errorf("failed to initialize repository detector: %w", err)
      }
      
      // Initialize task service
      if err := container.initTaskService(); err != nil {
          return nil, fmt.Errorf("failed to initialize task service: %w", err)
      }
      
      return container, nil
  }
  
  func (c *Container) initLogger() error {
      // Initially use default logger, will be reconfigured after loading config
      c.Logger = slog.New(slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{
          Level: slog.LevelInfo,
      }))
      return nil
  }
  
  func (c *Container) initConfig() error {
      configManager, err := NewViperConfigManager(c.Logger)
      if err != nil {
          return err
      }
      c.ConfigManager = configManager
      
      config, err := configManager.Load()
      if err != nil {
          return err
      }
      c.Config = config
      
      // Reconfigure logger with loaded settings
      return c.reconfigureLogger()
  }
  
  func (c *Container) reconfigureLogger() error {
      var handler slog.Handler
      
      level := slog.LevelInfo
      switch c.Config.Logging.Level {
      case "debug":
          level = slog.LevelDebug
      case "warn":
          level = slog.LevelWarn
      case "error":
          level = slog.LevelError
      }
      
      opts := &slog.HandlerOptions{Level: level}
      
      if c.Config.Logging.Format == "json" {
          handler = slog.NewJSONHandler(os.Stdout, opts)
      } else {
          handler = slog.NewTextHandler(os.Stdout, opts)
      }
      
      // Setup file output if configured
      if c.Config.Logging.File != "" {
          file, err := os.OpenFile(c.Config.Logging.File, 
              os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
          if err != nil {
              return fmt.Errorf("failed to open log file: %w", err)
          }
          
          if c.Config.Logging.Format == "json" {
              handler = slog.NewJSONHandler(file, opts)
          } else {
              handler = slog.NewTextHandler(file, opts)
          }
      }
      
      c.Logger = slog.New(handler)
      return nil
  }
  
  func (c *Container) initStorage() error {
      storage, err := NewFileStorage()
      if err != nil {
          return err
      }
      c.Storage = storage
      
      c.Logger.Info("storage initialized", 
          slog.String("type", "file"),
          slog.String("path", "~/.lmmc"))
      return nil
  }
  
  func (c *Container) initMCPClient() error {
      client := NewHTTPMCPClient(c.Config, c.Logger)
      c.MCPClient = client
      
      // Test connection (non-blocking)
      go func() {
          if err := client.TestConnection(); err != nil {
              c.Logger.Warn("MCP server not available, running in offline mode",
                  slog.Any("error", err))
          } else {
              c.Logger.Info("MCP server connection established")
          }
      }()
      
      return nil
  }
  
  func (c *Container) initRepositoryDetector() error {
      c.RepositoryDetector = &GitRepositoryDetector{}
      return nil
  }
  
  func (c *Container) initTaskService() error {
      service := NewTaskService(c.Storage, c.RepositoryDetector, c.Logger)
      c.TaskService = service
      
      c.Logger.Info("task service initialized")
      return nil
  }
  
  // Health check for critical dependencies
  func (c *Container) HealthCheck() error {
      // Check storage accessibility
      if err := c.Storage.HealthCheck(); err != nil {
          return fmt.Errorf("storage health check failed: %w", err)
      }
      
      // Check repository detection
      if _, err := c.RepositoryDetector.DetectCurrent(); err != nil {
          c.Logger.Warn("repository detection failed", slog.Any("error", err))
          // Not critical, continue
      }
      
      c.Logger.Debug("health check passed")
      return nil
  }
  
  // Graceful shutdown
  func (c *Container) Shutdown(ctx context.Context) error {
      c.Logger.Info("shutting down application")
      
      // Close any resources that need cleanup
      var errs []error
      
      // Flush any pending MCP operations
      if client, ok := c.MCPClient.(*HTTPMCPClient); ok {
          if err := client.Flush(ctx); err != nil {
              errs = append(errs, err)
          }
      }
      
      // Close storage connections
      if closer, ok := c.Storage.(io.Closer); ok {
          if err := closer.Close(); err != nil {
              errs = append(errs, err)
          }
      }
      
      if len(errs) > 0 {
          return fmt.Errorf("shutdown errors: %v", errs)
      }
      
      c.Logger.Info("application shutdown complete")
      return nil
  }
  
  // Main application entry point
  func main() {
      // Setup signal handling for graceful shutdown
      ctx, cancel := signal.NotifyContext(context.Background(), 
          os.Interrupt, syscall.SIGTERM)
      defer cancel()
      
      // Initialize application container
      container, err := NewContainer()
      if err != nil {
          fmt.Fprintf(os.Stderr, "Failed to initialize application: %v\n", err)
          os.Exit(1)
      }
      
      // Health check
      if err := container.HealthCheck(); err != nil {
          container.Logger.Error("health check failed", slog.Any("error", err))
          os.Exit(1)
      }
      
      // Setup CLI commands with container dependencies
      rootCmd := setupCommands(container)
      
      // Handle graceful shutdown
      go func() {
          <-ctx.Done()
          container.Logger.Info("shutdown signal received")
          
          shutdownCtx, shutdownCancel := context.WithTimeout(
              context.Background(), 10*time.Second)
          defer shutdownCancel()
          
          if err := container.Shutdown(shutdownCtx); err != nil {
              container.Logger.Error("shutdown failed", slog.Any("error", err))
              os.Exit(1)
          }
          
          os.Exit(0)
      }()
      
      // Execute CLI command
      if err := rootCmd.ExecuteContext(ctx); err != nil {
          container.Logger.Error("command execution failed", slog.Any("error", err))
          os.Exit(1)
      }
  }
  
  // Setup commands with dependency injection
  func setupCommands(container *Container) *cobra.Command {
      // Inject dependencies into command handlers
      commands := NewCommandHandlers(container.TaskService, container.ConfigManager, container.Logger)
      
      rootCmd := commands.RootCommand()
      rootCmd.AddCommand(
          commands.AddCommand(),
          commands.ListCommand(),
          commands.StartCommand(),
          commands.DoneCommand(),
          commands.EditCommand(),
          commands.ConfigCommand(),
      )
      
      return rootCmd
  }
  
  // Version information
  var (
      BuildVersion = "dev"
      BuildCommit  = "unknown"
      BuildDate    = "unknown"
  )
  
  func init() {
      // Set version information for root command
      rootCmd.Version = fmt.Sprintf("%s (commit: %s, built: %s)", 
          BuildVersion, BuildCommit, BuildDate)
  }
  ```

- **Configuration Changes:** None required
- **Dependencies:** Standard library, signal handling, context

## 4. Acceptance Criteria
- **Functional Criteria:**
  - Application starts up successfully with all dependencies
  - Configuration loading works from multiple sources
  - Graceful shutdown handles cleanup properly
  - Health checks validate critical dependencies
  - Error handling provides clear startup failure messages
  
- **Technical Criteria:**
  - Dependency injection container is maintainable
  - Component lifecycle is properly managed
  - Logging configuration is applied correctly
  - Signal handling works across platforms
  
- **Integration Criteria:**
  - All components are properly wired together
  - CLI commands have access to required dependencies
  - MCP client connection is established (when available)
  
- **Test Criteria:**
  - Container initialization can be tested
  - Dependency injection works correctly
  - Graceful shutdown completes within timeout

## 5. Testing Requirements
- **Unit Tests:**
  - Container initialization with various configurations
  - Dependency injection correctness
  - Health check functionality
  - Error handling for missing dependencies
  - Graceful shutdown operations
  - Logger reconfiguration

- **Integration Tests:**
  - End-to-end application startup process
  - Signal handling and graceful shutdown
  - Configuration loading from different sources
  
- **Manual Testing:**
  - Application startup in various environments
  - Behavior with missing configuration
  - Signal handling (Ctrl+C, SIGTERM)
  
- **Test Data:** Various configuration scenarios, startup failure conditions

## 6. Definition of Done
- **Code Complete:** Application bootstrap and DI container fully implemented
- **Tests Passing:** All startup and shutdown scenarios tested (â‰¥85% coverage)
- **Documentation Updated:** Application architecture and startup process documented
- **Integration Verified:** All components work together correctly
- **Review Approved:** Architecture and error handling review completed

## 7. Dependencies and Blockers
- **Required Sub-Tasks:** All previous sub-tasks (ST-MT-001-001 through ST-MT-001-006)
- **External Dependencies:** None (uses standard library)
- **Environmental Requirements:** Operating system signal handling support
- **Potential Blockers:** Dependency initialization order issues

## 8. Integration Notes
- **Component Interfaces:** Wires together all application components
- **Data Flow:** Configuration â†’ Dependencies â†’ CLI Commands â†’ User
- **Error Handling:** Centralized startup error handling with clear messages
- **Configuration Impact:** Central point for applying configuration to all components