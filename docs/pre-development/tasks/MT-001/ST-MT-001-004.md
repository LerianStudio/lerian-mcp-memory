# ST-MT-001-004: Implement CLI Commands with Cobra Framework

## Status
- **Status:** ✅ COMPLETED
- **Completion Date:** 2025-01-09  
- **Implementation:** Successfully implemented in `/Users/fredamaral/Repos/lerianstudio/lerian-mcp-memory/cli/internal/adapters/primary/cli/`
- **Actual Implementation:** Complete CLI command suite with all planned commands plus additional functionality
- **Deviations:** Added extra commands (search, stats, delete) and enhanced output formatting with multiple format options
- **Next Steps:** None - CLI implementation provides comprehensive task management interface

## 1. Sub-Task Overview
- **Sub-Task ID:** ST-MT-001-004
- **Sub-Task Name:** Implement CLI Commands with Cobra Framework
- **Parent Task:** MT-001: CLI Foundation with Local Storage and MCP Integration
- **Estimated Duration:** 4 hours
- **Implementation Type:** Code

## 2. Deliverable Specification
- **Primary Output:** Complete CLI command structure using Cobra framework
- **Code Location:** `cli/internal/adapters/primary/cli/commands.go` and `cli/cmd/lerian-mcp-memory-cli/main.go`
- **Technical Requirements:** Cobra CLI framework, command validation, output formatting
- **Interface Definition:** CLI commands: add, list, start, done, edit, priority, config

## 3. Implementation Details
- **Step-by-Step Approach:**
  1. Setup Cobra root command and CLI structure
  2. Implement `add` command for task creation
  3. Implement `list` command with filtering options
  4. Implement `start`, `done`, `cancel` commands for status updates
  5. Implement `edit` command for task modification
  6. Implement `priority` command for priority updates
  7. Implement `config` command for CLI configuration
  8. Add output formatting (table, JSON, plain text)
  9. Setup shell completion generation

- **Code Examples:**
  ```go
  // Root command setup
  var rootCmd = &cobra.Command{
      Use:   "lmmc",
      Short: "Lerian MCP Memory CLI - Intelligent task management",
      Long: `Lerian MCP Memory CLI (lmmc) is a powerful task management tool 
  that integrates with AI assistants and provides intelligent task suggestions.`,
      Version: version.BuildVersion,
  }
  
  // Add command
  var addCmd = &cobra.Command{
      Use:   "add [task description]",
      Short: "Create a new task",
      Long:  `Create a new task with the specified description in the current repository.`,
      Args:  cobra.MinimumNArgs(1),
      RunE: func(cmd *cobra.Command, args []string) error {
          content := strings.Join(args, " ")
          
          // Get options from flags
          priority, _ := cmd.Flags().GetString("priority")
          tags, _ := cmd.Flags().GetStringSlice("tags")
          estimated, _ := cmd.Flags().GetInt("estimate")
          
          // Create task options
          var options []TaskOption
          if priority != "" {
              if p, err := ParsePriority(priority); err == nil {
                  options = append(options, WithPriority(p))
              }
          }
          if len(tags) > 0 {
              options = append(options, WithTags(tags...))
          }
          if estimated > 0 {
              options = append(options, WithEstimatedTime(estimated))
          }
          
          task, err := taskService.CreateTask(cmd.Context(), content, options...)
          if err != nil {
              return fmt.Errorf("failed to create task: %w", err)
          }
          
          // Output task
          formatter := getOutputFormatter(cmd)
          return formatter.FormatTask(task)
      },
  }
  
  // List command with filtering
  var listCmd = &cobra.Command{
      Use:   "list",
      Short: "List tasks",
      Long:  `List tasks with optional filtering by status, priority, or tags.`,
      RunE: func(cmd *cobra.Command, args []string) error {
          // Parse filters from flags
          filters := TaskFilters{}
          
          if status, _ := cmd.Flags().GetString("status"); status != "" {
              if s, err := ParseStatus(status); err == nil {
                  filters.Status = &s
              }
          }
          
          if priority, _ := cmd.Flags().GetString("priority"); priority != "" {
              if p, err := ParsePriority(priority); err == nil {
                  filters.Priority = &p
              }
          }
          
          if tags, _ := cmd.Flags().GetStringSlice("tags"); len(tags) > 0 {
              filters.Tags = tags
          }
          
          tasks, err := taskService.ListTasks(cmd.Context(), filters)
          if err != nil {
              return fmt.Errorf("failed to list tasks: %w", err)
          }
          
          formatter := getOutputFormatter(cmd)
          return formatter.FormatTaskList(tasks)
      },
  }
  
  // Status update commands
  var startCmd = &cobra.Command{
      Use:   "start [task-id]",
      Short: "Mark a task as in progress",
      Args:  cobra.ExactArgs(1),
      RunE: func(cmd *cobra.Command, args []string) error {
          taskID := args[0]
          err := taskService.UpdateTaskStatus(cmd.Context(), taskID, StatusInProgress)
          if err != nil {
              return fmt.Errorf("failed to start task: %w", err)
          }
          
          fmt.Printf("Task %s marked as in progress\n", taskID)
          return nil
      },
  }
  
  var doneCmd = &cobra.Command{
      Use:   "done [task-id]",
      Short: "Mark a task as completed",
      Args:  cobra.ExactArgs(1),
      RunE: func(cmd *cobra.Command, args []string) error {
          taskID := args[0]
          err := taskService.UpdateTaskStatus(cmd.Context(), taskID, StatusCompleted)
          if err != nil {
              return fmt.Errorf("failed to complete task: %w", err)
          }
          
          fmt.Printf("Task %s marked as completed\n", taskID)
          return nil
      },
  }
  
  // Output formatter interface
  type OutputFormatter interface {
      FormatTask(task *Task) error
      FormatTaskList(tasks []*Task) error
  }
  
  type TableFormatter struct {
      writer io.Writer
  }
  
  func (f *TableFormatter) FormatTaskList(tasks []*Task) error {
      table := tablewriter.NewWriter(f.writer)
      table.SetHeader([]string{"ID", "Content", "Status", "Priority", "Created"})
      
      for _, task := range tasks {
          table.Append([]string{
              task.ID[:8], // Short ID
              truncateContent(task.Content, 50),
              string(task.Status),
              string(task.Priority),
              task.CreatedAt.Format("2006-01-02"),
          })
      }
      
      table.Render()
      return nil
  }
  
  // Configuration management
  var configCmd = &cobra.Command{
      Use:   "config",
      Short: "Manage CLI configuration",
  }
  
  var configSetCmd = &cobra.Command{
      Use:   "set [key] [value]",
      Short: "Set a configuration value",
      Args:  cobra.ExactArgs(2),
      RunE: func(cmd *cobra.Command, args []string) error {
          key, value := args[0], args[1]
          return configManager.Set(key, value)
      },
  }
  
  func init() {
      // Add command flags
      addCmd.Flags().StringP("priority", "p", "", "Task priority (low, medium, high)")
      addCmd.Flags().StringSliceP("tags", "t", nil, "Task tags")
      addCmd.Flags().IntP("estimate", "e", 0, "Estimated time in minutes")
      
      // List command flags  
      listCmd.Flags().StringP("status", "s", "", "Filter by status")
      listCmd.Flags().StringP("priority", "p", "", "Filter by priority")
      listCmd.Flags().StringSliceP("tags", "t", nil, "Filter by tags")
      
      // Global flags
      rootCmd.PersistentFlags().StringP("output", "o", "table", "Output format (table, json, plain)")
      rootCmd.PersistentFlags().BoolP("verbose", "v", false, "Verbose output")
      
      // Add commands to root
      rootCmd.AddCommand(addCmd, listCmd, startCmd, doneCmd, configCmd)
      configCmd.AddCommand(configSetCmd)
  }
  ```

- **Configuration Changes:** None required
- **Dependencies:**
  - `github.com/spf13/cobra`
  - `github.com/olekukonko/tablewriter`

## 4. Acceptance Criteria
- **Functional Criteria:**
  - All basic commands (add, list, start, done) work correctly
  - Command-line flags and arguments are properly parsed
  - Output formatting provides clear, readable results
  - Error messages are user-friendly and actionable
  - Shell completion can be generated and installed
  
- **Technical Criteria:**
  - Commands are well-structured and maintainable
  - Flag validation prevents invalid inputs
  - Output formatters are extensible
  - Command help text is comprehensive
  
- **Integration Criteria:**
  - Commands integrate seamlessly with TaskService
  - Error handling preserves context from service layer
  - Output formatting works across different terminals
  
- **Test Criteria:**
  - All command scenarios can be tested
  - Flag parsing works correctly
  - Output formatting is validated

## 5. Testing Requirements
- **Unit Tests:**
  - Command flag parsing and validation
  - Output formatter functionality
  - Error handling for invalid inputs
  - Command help text accuracy
  - Integration with TaskService methods
  - Configuration management operations

- **Integration Tests:**
  - End-to-end command execution
  - Cross-platform CLI behavior
  - Shell completion generation
  
- **Manual Testing:**
  - User workflow scenarios
  - Terminal compatibility testing
  - Shell completion installation
  
- **Test Data:** Mock TaskService for isolated command testing

## 6. Definition of Done
- **Code Complete:** All CLI commands implemented and working
- **Tests Passing:** Command testing achieves ≥85% coverage
- **Documentation Updated:** Command help text and examples complete
- **Integration Verified:** Works with TaskService and produces correct output
- **Review Approved:** User experience review completed

## 7. Dependencies and Blockers
- **Required Sub-Tasks:** ST-MT-001-003 (Task Service) must be complete
- **External Dependencies:** Cobra CLI framework, table formatting library
- **Environmental Requirements:** Go build environment, terminal testing
- **Potential Blockers:** Cross-platform terminal compatibility issues

## 8. Integration Notes
- **Component Interfaces:** Uses TaskService from domain layer
- **Data Flow:** User input → CLI parsing → TaskService → Storage
- **Error Handling:** Translates service errors to user-friendly messages
- **Configuration Impact:** Reads CLI configuration for defaults and preferences