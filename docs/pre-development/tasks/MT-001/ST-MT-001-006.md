# ST-MT-001-006: Implement MCP Integration Layer

## Status
- **Status:** âœ… COMPLETED
- **Completion Date:** 2025-01-09
- **Implementation:** Successfully implemented in `/Users/fredamaral/Repos/lerianstudio/lerian-mcp-memory/cli/internal/adapters/secondary/mcp/client.go`  
- **Actual Implementation:** Robust MCP client with comprehensive error handling, retry logic, and health monitoring
- **Deviations:** Added context support, graceful shutdown, mock client for testing, and enhanced protocol handling
- **Next Steps:** None - MCP integration provides reliable sync with memory server

## 1. Sub-Task Overview
- **Sub-Task ID:** ST-MT-001-006
- **Sub-Task Name:** Implement MCP Integration Layer
- **Parent Task:** MT-001: CLI Foundation with Local Storage and MCP Integration
- **Estimated Duration:** 4 hours
- **Implementation Type:** Code

## 2. Deliverable Specification
- **Primary Output:** MCP client integration for syncing with existing memory_tasks tools
- **Code Location:** `cli/internal/adapters/secondary/mcp/client.go`
- **Technical Requirements:** HTTP client, JSON-RPC protocol, error handling, retry logic
- **Interface Definition:** MCPClient interface with task synchronization methods

## 3. Implementation Details
- **Step-by-Step Approach:**
  1. Create MCP client interface and HTTP implementation
  2. Implement JSON-RPC protocol for MCP communication
  3. Add integration with existing memory_tasks tools
  4. Implement sync operations (push local tasks to Qdrant)
  5. Add conflict resolution with server as source of truth
  6. Implement connection testing and health checks
  7. Add retry logic with exponential backoff
  8. Create offline detection and graceful degradation

- **Code Examples:**
  ```go
  // MCP client interface
  type MCPClient interface {
      SyncTask(task *Task) error
      GetTasks(repository string) ([]*Task, error)
      UpdateTaskStatus(taskID string, status Status) error
      TestConnection() error
      IsOnline() bool
  }
  
  // HTTP MCP client implementation
  type HTTPMCPClient struct {
      baseURL    string
      httpClient *http.Client
      logger     *slog.Logger
      online     atomic.Bool
      retryConfig RetryConfig
  }
  
  type RetryConfig struct {
      MaxRetries int
      BaseDelay  time.Duration
      MaxDelay   time.Duration
  }
  
  func NewHTTPMCPClient(config *Config, logger *slog.Logger) *HTTPMCPClient {
      client := &HTTPMCPClient{
          baseURL: config.Server.URL,
          httpClient: &http.Client{
              Timeout: time.Duration(config.Server.Timeout) * time.Second,
          },
          logger: logger,
          retryConfig: RetryConfig{
              MaxRetries: 3,
              BaseDelay:  100 * time.Millisecond,
              MaxDelay:   5 * time.Second,
          },
      }
      
      // Test initial connection
      go client.periodicHealthCheck()
      
      return client
  }
  
  // MCP JSON-RPC request structure
  type MCPRequest struct {
      JSONRPC string      `json:"jsonrpc"`
      Method  string      `json:"method"`
      Params  interface{} `json:"params"`
      ID      int         `json:"id"`
  }
  
  type MCPResponse struct {
      JSONRPC string      `json:"jsonrpc"`
      Result  interface{} `json:"result,omitempty"`
      Error   *MCPError   `json:"error,omitempty"`
      ID      int         `json:"id"`
  }
  
  type MCPError struct {
      Code    int    `json:"code"`
      Message string `json:"message"`
      Data    interface{} `json:"data,omitempty"`
  }
  
  func (c *HTTPMCPClient) SyncTask(task *Task) error {
      if !c.IsOnline() {
          return ErrMCPOffline
      }
      
      // Convert task to MCP memory_tasks format
      mcpTask := c.convertToMCPFormat(task)
      
      request := MCPRequest{
          JSONRPC: "2.0",
          Method:  "memory_tasks/todo_write",
          Params: map[string]interface{}{
              "todos": []interface{}{mcpTask},
          },
          ID: 1,
      }
      
      return c.executeWithRetry(func() error {
          return c.sendMCPRequest(request)
      })
  }
  
  func (c *HTTPMCPClient) GetTasks(repository string) ([]*Task, error) {
      if !c.IsOnline() {
          return nil, ErrMCPOffline
      }
      
      request := MCPRequest{
          JSONRPC: "2.0",
          Method:  "memory_tasks/todo_read",
          Params: map[string]interface{}{
              "repository": repository,
          },
          ID: 2,
      }
      
      var response MCPResponse
      err := c.executeWithRetry(func() error {
          return c.sendMCPRequest(request, &response)
      })
      
      if err != nil {
          return nil, err
      }
      
      // Convert MCP response to tasks
      return c.convertFromMCPFormat(response.Result)
  }
  
  func (c *HTTPMCPClient) sendMCPRequest(request MCPRequest, response ...interface{}) error {
      requestBody, err := json.Marshal(request)
      if err != nil {
          return fmt.Errorf("failed to marshal request: %w", err)
      }
      
      resp, err := c.httpClient.Post(
          c.baseURL+"/mcp",
          "application/json",
          bytes.NewBuffer(requestBody),
      )
      if err != nil {
          c.setOffline()
          return fmt.Errorf("HTTP request failed: %w", err)
      }
      defer resp.Body.Close()
      
      if resp.StatusCode != http.StatusOK {
          c.setOffline()
          return fmt.Errorf("MCP server error: %d", resp.StatusCode)
      }
      
      if len(response) > 0 {
          if err := json.NewDecoder(resp.Body).Decode(response[0]); err != nil {
              return fmt.Errorf("failed to decode response: %w", err)
          }
      }
      
      c.setOnline()
      return nil
  }
  
  func (c *HTTPMCPClient) executeWithRetry(operation func() error) error {
      var lastErr error
      
      for attempt := 0; attempt <= c.retryConfig.MaxRetries; attempt++ {
          if err := operation(); err != nil {
              lastErr = err
              
              if attempt < c.retryConfig.MaxRetries {
                  delay := c.calculateBackoff(attempt)
                  c.logger.Warn("MCP operation failed, retrying",
                      slog.Int("attempt", attempt+1),
                      slog.Duration("delay", delay),
                      slog.Any("error", err))
                  time.Sleep(delay)
                  continue
              }
          } else {
              return nil
          }
      }
      
      return fmt.Errorf("operation failed after %d attempts: %w", 
          c.retryConfig.MaxRetries+1, lastErr)
  }
  
  func (c *HTTPMCPClient) calculateBackoff(attempt int) time.Duration {
      delay := c.retryConfig.BaseDelay * time.Duration(1<<attempt)
      if delay > c.retryConfig.MaxDelay {
          delay = c.retryConfig.MaxDelay
      }
      return delay
  }
  
  func (c *HTTPMCPClient) TestConnection() error {
      request := MCPRequest{
          JSONRPC: "2.0",
          Method:  "memory_tasks/version",
          Params:  map[string]interface{}{},
          ID:      99,
      }
      
      return c.sendMCPRequest(request)
  }
  
  func (c *HTTPMCPClient) periodicHealthCheck() {
      ticker := time.NewTicker(30 * time.Second)
      defer ticker.Stop()
      
      for {
          select {
          case <-ticker.C:
              if err := c.TestConnection(); err != nil {
                  c.setOffline()
                  c.logger.Debug("MCP health check failed", slog.Any("error", err))
              } else {
                  c.setOnline()
              }
          }
      }
  }
  
  func (c *HTTPMCPClient) IsOnline() bool {
      return c.online.Load()
  }
  
  func (c *HTTPMCPClient) setOnline() {
      if !c.online.Load() {
          c.online.Store(true)
          c.logger.Info("MCP connection restored")
      }
  }
  
  func (c *HTTPMCPClient) setOffline() {
      if c.online.Load() {
          c.online.Store(false)
          c.logger.Warn("MCP connection lost")
      }
  }
  
  // Task format conversion
  func (c *HTTPMCPClient) convertToMCPFormat(task *Task) map[string]interface{} {
      return map[string]interface{}{
          "id":       task.ID,
          "content":  task.Content,
          "status":   string(task.Status),
          "priority": string(task.Priority),
          "repository": task.Repository,
          "created_at": task.CreatedAt.Format(time.RFC3339),
          "updated_at": task.UpdatedAt.Format(time.RFC3339),
          "tags":     task.Tags,
      }
  }
  
  func (c *HTTPMCPClient) convertFromMCPFormat(data interface{}) ([]*Task, error) {
      // Convert MCP response format back to Task entities
      // Implementation depends on MCP memory_tasks response format
      return nil, nil
  }
  
  var ErrMCPOffline = errors.New("MCP server is offline")
  ```

- **Configuration Changes:** Uses server.url from configuration
- **Dependencies:** Standard library HTTP client, JSON handling

## 4. Acceptance Criteria
- **Functional Criteria:**
  - Successfully syncs tasks with MCP Memory Server
  - Handles connection failures gracefully with offline mode
  - Retry logic recovers from transient failures
  - Task format conversion maintains data integrity
  - Health checks detect server availability changes
  
- **Technical Criteria:**
  - JSON-RPC protocol implementation is correct
  - Error handling provides clear feedback
  - Retry logic uses exponential backoff
  - Thread-safe operation for concurrent usage
  
- **Integration Criteria:**
  - Integrates with existing memory_tasks MCP tools
  - Works with TaskService for sync operations
  - Offline detection enables local-only operation
  
- **Test Criteria:**
  - All MCP communication scenarios tested
  - Retry logic and backoff algorithms validated
  - Offline/online transitions work correctly

## 5. Testing Requirements
- **Unit Tests:**
  - JSON-RPC request/response formatting
  - Task format conversion accuracy
  - Retry logic with various failure scenarios
  - Health check and connection status management
  - Exponential backoff calculation
  - Thread safety for concurrent operations
  - Error handling for malformed responses

- **Integration Tests:**
  - End-to-end communication with real MCP server
  - Network failure simulation and recovery
  - Large dataset synchronization performance
  
- **Manual Testing:**
  - Server offline/online scenario testing
  - Network interruption handling
  - Task data integrity verification
  
- **Test Data:** Mock MCP server responses, various task datasets

## 6. Definition of Done
- **Code Complete:** MCP client fully implements synchronization interface
- **Tests Passing:** All sync scenarios tested (â‰¥85% coverage)
- **Documentation Updated:** MCP integration process documented
- **Integration Verified:** Works with existing memory_tasks tools
- **Review Approved:** Protocol compliance and security review completed

## 7. Dependencies and Blockers
- **Required Sub-Tasks:** ST-MT-001-001 (Task Entity) and ST-MT-001-005 (Configuration)
- **External Dependencies:** Access to running MCP Memory Server
- **Environmental Requirements:** Network connectivity to server
- **Potential Blockers:** MCP protocol changes, network configuration issues

## 8. Integration Notes
- **Component Interfaces:** Implements MCPClient interface for TaskService
- **Data Flow:** Local tasks â†’ MCP format â†’ Server â†’ Qdrant storage
- **Error Handling:** Graceful degradation to local-only mode when offline
- **Configuration Impact:** Uses server URL and timeout from configuration