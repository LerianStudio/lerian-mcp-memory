# ST-MT-001-005: Implement Configuration Management System

## 1. Sub-Task Overview
- **Sub-Task ID:** ST-MT-001-005
- **Sub-Task Name:** Implement Configuration Management System
- **Parent Task:** MT-001: CLI Foundation with Local Storage and MCP Integration
- **Estimated Duration:** 3 hours
- **Implementation Type:** Code

## 2. Deliverable Specification
- **Primary Output:** Configuration management system with Viper integration
- **Code Location:** `cli/internal/adapters/config/viper.go` and `cli/internal/domain/entities/config.go`
- **Technical Requirements:** Viper configuration, environment variables, validation
- **Interface Definition:** Config struct and ConfigManager interface

## 3. Implementation Details
- **Step-by-Step Approach:**
  1. Define configuration struct with all CLI settings
  2. Setup Viper configuration management
  3. Implement environment variable support
  4. Add configuration file handling (~/.lmmc/config.yaml)
  5. Implement configuration validation
  6. Add default value management
  7. Create configuration update methods
  8. Setup XDG Base Directory specification support

- **Code Examples:**
  ```go
  // Configuration structure
  type Config struct {
      Server struct {
          URL     string `mapstructure:"url" validate:"required,url"`
          Version string `mapstructure:"version"`
          Timeout int    `mapstructure:"timeout" validate:"min=1,max=300"`
      } `mapstructure:"server"`
      
      CLI struct {
          DefaultRepository string   `mapstructure:"default_repository"`
          OutputFormat      string   `mapstructure:"output_format" validate:"oneof=table json plain"`
          AutoComplete      bool     `mapstructure:"auto_complete"`
          ColorScheme       string   `mapstructure:"color_scheme"`
          PageSize          int      `mapstructure:"page_size" validate:"min=1,max=100"`
      } `mapstructure:"cli"`
      
      Storage struct {
          CacheEnabled bool   `mapstructure:"cache_enabled"`
          CacheTTL     int    `mapstructure:"cache_ttl" validate:"min=1"`
          BackupCount  int    `mapstructure:"backup_count" validate:"min=0,max=10"`
      } `mapstructure:"storage"`
      
      Logging struct {
          Level  string `mapstructure:"level" validate:"oneof=debug info warn error"`
          Format string `mapstructure:"format" validate:"oneof=json text"`
          File   string `mapstructure:"file"`
      } `mapstructure:"logging"`
  }
  
  // Configuration manager interface
  type ConfigManager interface {
      Load() (*Config, error)
      Save(config *Config) error
      Set(key, value string) error
      Get(key string) (interface{}, error)
      GetConfigPath() string
      Validate() error
  }
  
  // Viper implementation
  type ViperConfigManager struct {
      viper     *viper.Viper
      validator *validator.Validate
      configDir string
      logger    *slog.Logger
  }
  
  func NewViperConfigManager(logger *slog.Logger) (*ViperConfigManager, error) {
      v := viper.New()
      
      // Setup configuration directory (XDG compliant)
      configDir, err := getConfigDirectory()
      if err != nil {
          return nil, fmt.Errorf("failed to get config directory: %w", err)
      }
      
      // Ensure config directory exists
      if err := os.MkdirAll(configDir, 0755); err != nil {
          return nil, fmt.Errorf("failed to create config directory: %w", err)
      }
      
      // Setup Viper
      v.SetConfigName("config")
      v.SetConfigType("yaml")
      v.AddConfigPath(configDir)
      
      // Environment variable support
      v.SetEnvPrefix("LMMC")
      v.AutomaticEnv()
      v.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
      
      // Set defaults
      setDefaults(v)
      
      return &ViperConfigManager{
          viper:     v,
          validator: validator.New(),
          configDir: configDir,
          logger:    logger,
      }, nil
  }
  
  func setDefaults(v *viper.Viper) {
      // Server defaults
      v.SetDefault("server.url", "http://localhost:9080")
      v.SetDefault("server.timeout", 30)
      
      // CLI defaults
      v.SetDefault("cli.output_format", "table")
      v.SetDefault("cli.auto_complete", true)
      v.SetDefault("cli.color_scheme", "auto")
      v.SetDefault("cli.page_size", 20)
      
      // Storage defaults
      v.SetDefault("storage.cache_enabled", true)
      v.SetDefault("storage.cache_ttl", 300)
      v.SetDefault("storage.backup_count", 3)
      
      // Logging defaults
      v.SetDefault("logging.level", "info")
      v.SetDefault("logging.format", "text")
  }
  
  func (c *ViperConfigManager) Load() (*Config, error) {
      // Try to read config file
      if err := c.viper.ReadInConfig(); err != nil {
          if _, ok := err.(viper.ConfigFileNotFoundError); !ok {
              return nil, fmt.Errorf("failed to read config file: %w", err)
          }
          // Config file not found is OK, we'll use defaults
          c.logger.Info("config file not found, using defaults")
      } else {
          c.logger.Info("loaded config file", slog.String("path", c.viper.ConfigFileUsed()))
      }
      
      var config Config
      if err := c.viper.Unmarshal(&config); err != nil {
          return nil, fmt.Errorf("failed to unmarshal config: %w", err)
      }
      
      if err := c.validator.Struct(&config); err != nil {
          return nil, fmt.Errorf("invalid configuration: %w", err)
      }
      
      return &config, nil
  }
  
  func (c *ViperConfigManager) Save(config *Config) error {
      if err := c.validator.Struct(config); err != nil {
          return fmt.Errorf("invalid configuration: %w", err)
      }
      
      // Convert struct to map for Viper
      configMap := make(map[string]interface{})
      if err := mapstructure.Decode(config, &configMap); err != nil {
          return fmt.Errorf("failed to encode config: %w", err)
      }
      
      // Update Viper with new values
      for key, value := range flattenMap(configMap) {
          c.viper.Set(key, value)
      }
      
      // Write to file
      configPath := filepath.Join(c.configDir, "config.yaml")
      if err := c.viper.WriteConfigAs(configPath); err != nil {
          return fmt.Errorf("failed to write config file: %w", err)
      }
      
      c.logger.Info("config saved", slog.String("path", configPath))
      return nil
  }
  
  func (c *ViperConfigManager) Set(key, value string) error {
      // Validate key exists in config structure
      if !c.isValidConfigKey(key) {
          return fmt.Errorf("invalid configuration key: %s", key)
      }
      
      c.viper.Set(key, value)
      
      // Save updated configuration
      config, err := c.Load()
      if err != nil {
          return err
      }
      
      return c.Save(config)
  }
  
  func getConfigDirectory() (string, error) {
      // XDG Base Directory specification
      if xdgConfigHome := os.Getenv("XDG_CONFIG_HOME"); xdgConfigHome != "" {
          return filepath.Join(xdgConfigHome, "lmmc"), nil
      }
      
      // Fallback to ~/.lmmc for compatibility
      homeDir, err := os.UserHomeDir()
      if err != nil {
          return "", err
      }
      
      return filepath.Join(homeDir, ".lmmc"), nil
  }
  
  // Repository detection
  type RepositoryDetector interface {
      DetectCurrent() (string, error)
      IsRepository(path string) bool
  }
  
  type GitRepositoryDetector struct{}
  
  func (g *GitRepositoryDetector) DetectCurrent() (string, error) {
      cmd := exec.Command("git", "remote", "get-url", "origin")
      output, err := cmd.Output()
      if err != nil {
          // Fallback to directory name
          wd, err := os.Getwd()
          if err != nil {
              return "", err
          }
          return filepath.Base(wd), nil
      }
      
      // Parse git URL to repository name
      url := strings.TrimSpace(string(output))
      return parseRepositoryName(url), nil
  }
  ```

- **Configuration Changes:** Creates ~/.lmmc/config.yaml on first use
- **Dependencies:**
  - `github.com/spf13/viper`
  - `github.com/go-playground/validator/v10`
  - `github.com/mitchellh/mapstructure`

## 4. Acceptance Criteria
- **Functional Criteria:**
  - Configuration loads from file, environment, and defaults
  - XDG Base Directory specification supported
  - Configuration validation prevents invalid settings
  - Repository auto-detection works in git repositories
  - Configuration updates persist correctly
  
- **Technical Criteria:**
  - Environment variables override file settings
  - Default values provide sensible CLI behavior
  - Configuration validation provides clear error messages
  - File permissions are secure (644 for config files)
  
- **Integration Criteria:**
  - Used by CLI commands for default behavior
  - Integrates with TaskService for repository detection
  - Error handling provides actionable feedback
  
- **Test Criteria:**
  - All configuration scenarios tested
  - Validation rules enforce correct values
  - File operations work across platforms

## 5. Testing Requirements
- **Unit Tests:**
  - Configuration loading from various sources
  - Environment variable override behavior
  - Validation for all configuration fields
  - Default value application
  - Repository detection in different scenarios
  - Configuration file creation and updates
  - XDG directory detection logic

- **Integration Tests:**
  - Cross-platform configuration directory creation
  - Git repository detection accuracy
  - Configuration persistence across CLI sessions
  
- **Manual Testing:**
  - Configuration file format and readability
  - Environment variable functionality
  - Repository detection in various project types
  
- **Test Data:** Various configuration scenarios and invalid configurations

## 6. Definition of Done
- **Code Complete:** Configuration management fully implemented
- **Tests Passing:** All configuration scenarios tested (â‰¥90% coverage)
- **Documentation Updated:** Configuration options documented with examples
- **Integration Verified:** Used by CLI commands and services
- **Review Approved:** Security and usability review completed

## 7. Dependencies and Blockers
- **Required Sub-Tasks:** None (can be developed independently)
- **External Dependencies:** Viper configuration library
- **Environmental Requirements:** File system access for config directory
- **Potential Blockers:** XDG specification compatibility across platforms

## 8. Integration Notes
- **Component Interfaces:** Provides ConfigManager interface for dependency injection
- **Data Flow:** Environment/Files â†’ Viper â†’ Config struct â†’ CLI behavior
- **Error Handling:** Clear validation errors guide users to fix configuration
- **Configuration Impact:** Creates ~/.lmmc/config.yaml with documented defaults