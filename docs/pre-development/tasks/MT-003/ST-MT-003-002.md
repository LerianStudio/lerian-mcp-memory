# ST-MT-003-002: Implement Task CRUD API Endpoints

## 1. Sub-Task Overview
- **Sub-Task ID:** ST-MT-003-002
- **Sub-Task Name:** Implement Task CRUD API Endpoints
- **Parent Task:** MT-003: Bidirectional Server Integration and Real-Time Sync
- **Estimated Duration:** 3 hours
- **Implementation Type:** Code

## 2. Deliverable Specification
- **Primary Output:** RESTful API endpoints for task create, read, update, delete operations
- **Code Location:** 
  - `internal/adapters/api/handlers/task_handlers.go` - Task request handlers
  - `internal/adapters/api/models/` - API request/response models
  - `internal/adapters/api/routes/task_routes.go` - Task route definitions
- **Technical Requirements:** RESTful design, JSON validation, proper HTTP status codes
- **Interface Definition:** Standard REST endpoints for task management

## 3. Implementation Details
- **Step-by-Step Approach:**
  1. Create API request/response models with validation
  2. Implement task creation handler (POST /api/v1/tasks)
  3. Implement task listing handler (GET /api/v1/tasks)
  4. Implement single task retrieval (GET /api/v1/tasks/{id})
  5. Implement task update handler (PUT /api/v1/tasks/{id})
  6. Implement task deletion handler (DELETE /api/v1/tasks/{id})
  7. Add query parameter support for filtering
  8. Implement pagination for task listing
  9. Add field validation and error responses
  10. Register routes with Chi router

- **Code Examples:**
  ```go
  // API models
  package models
  
  import (
      "time"
      "github.com/go-playground/validator/v10"
  )
  
  type CreateTaskRequest struct {
      Content    string `json:"content" validate:"required,min=1,max=1000"`
      Priority   string `json:"priority" validate:"required,oneof=low medium high"`
      Repository string `json:"repository" validate:"required"`
  }
  
  type UpdateTaskRequest struct {
      Content  *string `json:"content,omitempty" validate:"omitempty,min=1,max=1000"`
      Status   *string `json:"status,omitempty" validate:"omitempty,oneof=pending in_progress completed cancelled"`
      Priority *string `json:"priority,omitempty" validate:"omitempty,oneof=low medium high"`
  }
  
  type TaskResponse struct {
      ID         string    `json:"id"`
      Content    string    `json:"content"`
      Status     string    `json:"status"`
      Priority   string    `json:"priority"`
      Repository string    `json:"repository"`
      CreatedAt  time.Time `json:"created_at"`
      UpdatedAt  time.Time `json:"updated_at"`
      Metadata   map[string]interface{} `json:"metadata,omitempty"`
  }
  
  type TaskListResponse struct {
      Tasks      []TaskResponse `json:"tasks"`
      TotalCount int           `json:"total_count"`
      Page       int           `json:"page"`
      PageSize   int           `json:"page_size"`
      HasMore    bool          `json:"has_more"`
  }
  
  // Task handlers
  package handlers
  
  type TaskHandlers struct {
      taskStore storage.TaskStorage
      validator *validator.Validate
      logger    *slog.Logger
  }
  
  func NewTaskHandlers(taskStore storage.TaskStorage, logger *slog.Logger) *TaskHandlers {
      return &TaskHandlers{
          taskStore: taskStore,
          validator: validator.New(),
          logger:    logger,
      }
  }
  
  // POST /api/v1/tasks
  func (h *TaskHandlers) CreateTask(w http.ResponseWriter, r *http.Request) {
      var req models.CreateTaskRequest
      
      if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
          h.respondError(w, r, http.StatusBadRequest, "invalid request body")
          return
      }
      
      if err := h.validator.Struct(req); err != nil {
          h.respondValidationError(w, r, err)
          return
      }
      
      // Create task entity
      task := &types.Task{
          ID:         uuid.New().String(),
          Content:    req.Content,
          Status:     "pending",
          Priority:   req.Priority,
          Repository: req.Repository,
          CreatedAt:  time.Now(),
          UpdatedAt:  time.Now(),
          Metadata:   make(map[string]interface{}),
      }
      
      // Store task
      if err := h.taskStore.Create(r.Context(), task); err != nil {
          h.logger.Error("failed to create task", slog.Any("error", err))
          h.respondError(w, r, http.StatusInternalServerError, "failed to create task")
          return
      }
      
      // Convert to response
      response := h.taskToResponse(task)
      h.respondJSON(w, r, http.StatusCreated, response)
  }
  
  // GET /api/v1/tasks
  func (h *TaskHandlers) ListTasks(w http.ResponseWriter, r *http.Request) {
      // Parse query parameters
      query := r.URL.Query()
      status := query.Get("status")
      priority := query.Get("priority")
      repository := query.Get("repository")
      
      // Pagination
      page, _ := strconv.Atoi(query.Get("page"))
      if page < 1 {
          page = 1
      }
      
      pageSize, _ := strconv.Atoi(query.Get("page_size"))
      if pageSize < 1 || pageSize > 100 {
          pageSize = 20
      }
      
      // Build filter
      filter := storage.TaskFilter{
          Status:     status,
          Priority:   priority,
          Repository: repository,
          Limit:      pageSize,
          Offset:     (page - 1) * pageSize,
      }
      
      // Get tasks
      tasks, totalCount, err := h.taskStore.List(r.Context(), filter)
      if err != nil {
          h.logger.Error("failed to list tasks", slog.Any("error", err))
          h.respondError(w, r, http.StatusInternalServerError, "failed to list tasks")
          return
      }
      
      // Convert to response
      taskResponses := make([]models.TaskResponse, 0, len(tasks))
      for _, task := range tasks {
          taskResponses = append(taskResponses, h.taskToResponse(task))
      }
      
      response := models.TaskListResponse{
          Tasks:      taskResponses,
          TotalCount: totalCount,
          Page:       page,
          PageSize:   pageSize,
          HasMore:    totalCount > page*pageSize,
      }
      
      h.respondJSON(w, r, http.StatusOK, response)
  }
  
  // GET /api/v1/tasks/{id}
  func (h *TaskHandlers) GetTask(w http.ResponseWriter, r *http.Request) {
      taskID := chi.URLParam(r, "id")
      
      task, err := h.taskStore.GetByID(r.Context(), taskID)
      if err != nil {
          if errors.Is(err, storage.ErrNotFound) {
              h.respondError(w, r, http.StatusNotFound, "task not found")
              return
          }
          h.logger.Error("failed to get task", slog.Any("error", err))
          h.respondError(w, r, http.StatusInternalServerError, "failed to get task")
          return
      }
      
      response := h.taskToResponse(task)
      h.respondJSON(w, r, http.StatusOK, response)
  }
  
  // PUT /api/v1/tasks/{id}
  func (h *TaskHandlers) UpdateTask(w http.ResponseWriter, r *http.Request) {
      taskID := chi.URLParam(r, "id")
      
      var req models.UpdateTaskRequest
      if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
          h.respondError(w, r, http.StatusBadRequest, "invalid request body")
          return
      }
      
      if err := h.validator.Struct(req); err != nil {
          h.respondValidationError(w, r, err)
          return
      }
      
      // Get existing task
      task, err := h.taskStore.GetByID(r.Context(), taskID)
      if err != nil {
          if errors.Is(err, storage.ErrNotFound) {
              h.respondError(w, r, http.StatusNotFound, "task not found")
              return
          }
          h.logger.Error("failed to get task", slog.Any("error", err))
          h.respondError(w, r, http.StatusInternalServerError, "failed to get task")
          return
      }
      
      // Update fields
      if req.Content != nil {
          task.Content = *req.Content
      }
      if req.Status != nil {
          task.Status = *req.Status
      }
      if req.Priority != nil {
          task.Priority = *req.Priority
      }
      task.UpdatedAt = time.Now()
      
      // Save updates
      if err := h.taskStore.Update(r.Context(), task); err != nil {
          h.logger.Error("failed to update task", slog.Any("error", err))
          h.respondError(w, r, http.StatusInternalServerError, "failed to update task")
          return
      }
      
      response := h.taskToResponse(task)
      h.respondJSON(w, r, http.StatusOK, response)
  }
  
  // DELETE /api/v1/tasks/{id}
  func (h *TaskHandlers) DeleteTask(w http.ResponseWriter, r *http.Request) {
      taskID := chi.URLParam(r, "id")
      
      if err := h.taskStore.Delete(r.Context(), taskID); err != nil {
          if errors.Is(err, storage.ErrNotFound) {
              h.respondError(w, r, http.StatusNotFound, "task not found")
              return
          }
          h.logger.Error("failed to delete task", slog.Any("error", err))
          h.respondError(w, r, http.StatusInternalServerError, "failed to delete task")
          return
      }
      
      w.WriteHeader(http.StatusNoContent)
  }
  
  // Route registration
  package routes
  
  func RegisterTaskRoutes(r chi.Router, handlers *handlers.TaskHandlers) {
      r.Route("/tasks", func(r chi.Router) {
          r.Post("/", handlers.CreateTask)
          r.Get("/", handlers.ListTasks)
          
          r.Route("/{id}", func(r chi.Router) {
              r.Get("/", handlers.GetTask)
              r.Put("/", handlers.UpdateTask)
              r.Delete("/", handlers.DeleteTask)
          })
      })
  }
  ```

- **Configuration Changes:** None required
- **Dependencies:** Already included from ST-MT-003-001

## 4. Acceptance Criteria
- **Functional Criteria:**
  - POST /tasks creates new task and returns 201
  - GET /tasks returns paginated task list
  - GET /tasks/{id} returns single task or 404
  - PUT /tasks/{id} updates task fields
  - DELETE /tasks/{id} removes task
  - Query parameters filter results correctly
  - Pagination works with accurate counts
  
- **Technical Criteria:**
  - Request validation prevents invalid data
  - Proper HTTP status codes returned
  - JSON response format consistent
  - Error messages are helpful
  - Concurrent requests handled safely
  
- **Integration Criteria:**
  - Uses same storage as MCP tools
  - Task changes visible to MCP tools
  - Repository filtering works correctly
  
- **Test Criteria:**
  - All CRUD operations tested
  - Validation errors return 400
  - Not found returns 404
  - Pagination edge cases handled

## 5. Testing Requirements
- **Unit Tests:**
  - Request model validation
  - Response conversion logic
  - Query parameter parsing
  - Pagination calculations
  - Error handling paths
  
- **Integration Tests:**
  - Full CRUD cycle test
  - Concurrent task operations
  - Filter combinations
  - Pagination boundaries
  - Invalid ID handling
  
- **Manual Testing:**
  - Create task via curl/Postman
  - List tasks with filters
  - Update task fields
  - Delete task verification
  
- **Test Data:**
  - Valid/invalid task payloads
  - Various filter combinations
  - Edge case task IDs

## 6. Definition of Done
- **Code Complete:** All CRUD endpoints implemented and working
- **Tests Passing:** Unit and integration tests passing (≥85% coverage)
- **Documentation Updated:** API endpoint documentation complete
- **Integration Verified:** Changes visible in MCP tools
- **Review Approved:** REST conventions and security reviewed

## 7. Dependencies and Blockers
- **Required Sub-Tasks:** ST-MT-003-001 (HTTP Server foundation)
- **External Dependencies:** None (uses existing libraries)
- **Environmental Requirements:** Running storage layer
- **Potential Blockers:** Storage interface compatibility

## 8. Integration Notes
- **Component Interfaces:** REST API for CLI and other clients
- **Data Flow:** HTTP Request → Validation → Storage → Response
- **Error Handling:** Consistent error format with helpful messages
- **Configuration Impact:** None beyond base server config