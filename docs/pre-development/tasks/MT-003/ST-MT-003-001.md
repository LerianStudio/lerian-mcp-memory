# ST-MT-003-001: Create HTTP API Layer with Chi Router

## 1. Sub-Task Overview
- **Sub-Task ID:** ST-MT-003-001
- **Sub-Task Name:** Create HTTP API Layer with Chi Router
- **Parent Task:** MT-003: Bidirectional Server Integration and Real-Time Sync
- **Estimated Duration:** 4 hours
- **Implementation Type:** Code

## 2. Deliverable Specification
- **Primary Output:** HTTP API server layer with Chi router, middleware, and core endpoints
- **Code Location:** 
  - `internal/adapters/api/http_server.go` - Main HTTP server
  - `internal/adapters/api/middleware/` - Common middleware
  - `internal/adapters/api/routes/` - Route definitions
  - `internal/adapters/api/handlers/` - Request handlers
- **Technical Requirements:** Chi router, JSON serialization, error handling, rate limiting
- **Interface Definition:** RESTful API endpoints for task CRUD operations

## 3. Implementation Details
- **Step-by-Step Approach:**
  1. Install Chi router dependency and create server structure
  2. Create base HTTP server with graceful shutdown
  3. Implement common middleware (CORS, logging, recovery)
  4. Add rate limiting middleware for API protection
  5. Create version compatibility checking middleware
  6. Define base route structure with versioning (/api/v1)
  7. Implement health check endpoint
  8. Create error response handling utilities
  9. Add request/response logging middleware
  10. Setup context handling and timeout configuration

- **Code Examples:**
  ```go
  // HTTP server structure
  package api
  
  import (
      "context"
      "net/http"
      "time"
      
      "github.com/go-chi/chi/v5"
      "github.com/go-chi/chi/v5/middleware"
      "github.com/go-chi/cors"
      "github.com/go-chi/httprate"
  )
  
  type HTTPServer struct {
      router     *chi.Mux
      server     *http.Server
      config     *ServerConfig
      logger     *slog.Logger
      taskStore  storage.TaskStorage
  }
  
  type ServerConfig struct {
      Port              int           `mapstructure:"port"`
      ReadTimeout       time.Duration `mapstructure:"read_timeout"`
      WriteTimeout      time.Duration `mapstructure:"write_timeout"`
      IdleTimeout       time.Duration `mapstructure:"idle_timeout"`
      RateLimitRequests int           `mapstructure:"rate_limit_requests"`
      RateLimitWindow   time.Duration `mapstructure:"rate_limit_window"`
  }
  
  func NewHTTPServer(config *ServerConfig, taskStore storage.TaskStorage, logger *slog.Logger) *HTTPServer {
      server := &HTTPServer{
          config:    config,
          logger:    logger,
          taskStore: taskStore,
      }
      
      server.setupRoutes()
      return server
  }
  
  func (s *HTTPServer) setupRoutes() {
      r := chi.NewRouter()
      
      // Common middleware
      r.Use(middleware.RequestID)
      r.Use(middleware.RealIP)
      r.Use(s.loggingMiddleware)
      r.Use(middleware.Recoverer)
      r.Use(middleware.Timeout(60 * time.Second))
      
      // CORS configuration
      r.Use(cors.Handler(cors.Options{
          AllowedOrigins:   []string{"http://localhost:*"},
          AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
          AllowedHeaders:   []string{"Accept", "Authorization", "Content-Type", "X-CSRF-Token", "X-Version"},
          ExposedHeaders:   []string{"Link", "X-Version"},
          AllowCredentials: true,
          MaxAge:           300,
      }))
      
      // Rate limiting
      r.Use(httprate.LimitByIP(s.config.RateLimitRequests, s.config.RateLimitWindow))
      
      // Version compatibility
      r.Use(s.versionCheckMiddleware)
      
      // Health check (no version check)
      r.Get("/health", s.handleHealth)
      
      // API v1 routes
      r.Route("/api/v1", func(r chi.Router) {
          // Task routes will be added in next sub-task
      })
      
      s.router = r
  }
  
  func (s *HTTPServer) Start(ctx context.Context) error {
      s.server = &http.Server{
          Addr:         fmt.Sprintf(":%d", s.config.Port),
          Handler:      s.router,
          ReadTimeout:  s.config.ReadTimeout,
          WriteTimeout: s.config.WriteTimeout,
          IdleTimeout:  s.config.IdleTimeout,
      }
      
      // Graceful shutdown
      go func() {
          <-ctx.Done()
          shutdownCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
          defer cancel()
          
          s.logger.Info("shutting down HTTP server")
          if err := s.server.Shutdown(shutdownCtx); err != nil {
              s.logger.Error("HTTP server shutdown error", slog.Any("error", err))
          }
      }()
      
      s.logger.Info("starting HTTP server", slog.Int("port", s.config.Port))
      if err := s.server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
          return fmt.Errorf("HTTP server error: %w", err)
      }
      
      return nil
  }
  
  // Middleware implementations
  func (s *HTTPServer) loggingMiddleware(next http.Handler) http.Handler {
      return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
          start := time.Now()
          
          ww := middleware.NewWrapResponseWriter(w, r.ProtoMajor)
          next.ServeHTTP(ww, r)
          
          s.logger.Info("http request",
              slog.String("method", r.Method),
              slog.String("path", r.URL.Path),
              slog.Int("status", ww.Status()),
              slog.Int("bytes", ww.BytesWritten()),
              slog.Duration("duration", time.Since(start)),
              slog.String("request_id", middleware.GetReqID(r.Context())),
          )
      })
  }
  
  func (s *HTTPServer) versionCheckMiddleware(next http.Handler) http.Handler {
      return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
          // Skip version check for health endpoint
          if r.URL.Path == "/health" {
              next.ServeHTTP(w, r)
              return
          }
          
          clientVersion := r.Header.Get("X-Version")
          if clientVersion == "" {
              s.respondError(w, r, http.StatusBadRequest, "missing X-Version header")
              return
          }
          
          // Version compatibility logic
          if !s.isVersionCompatible(clientVersion) {
              s.respondError(w, r, http.StatusBadRequest, 
                  fmt.Sprintf("incompatible version %s, server version %s", clientVersion, ServerVersion))
              return
          }
          
          // Add server version to response
          w.Header().Set("X-Version", ServerVersion)
          next.ServeHTTP(w, r)
      })
  }
  
  // Error response utilities
  type ErrorResponse struct {
      Error     string `json:"error"`
      Message   string `json:"message"`
      RequestID string `json:"request_id"`
      Timestamp string `json:"timestamp"`
  }
  
  func (s *HTTPServer) respondError(w http.ResponseWriter, r *http.Request, code int, message string) {
      response := ErrorResponse{
          Error:     http.StatusText(code),
          Message:   message,
          RequestID: middleware.GetReqID(r.Context()),
          Timestamp: time.Now().UTC().Format(time.RFC3339),
      }
      
      s.respondJSON(w, r, code, response)
  }
  
  func (s *HTTPServer) respondJSON(w http.ResponseWriter, r *http.Request, code int, data interface{}) {
      w.Header().Set("Content-Type", "application/json")
      w.WriteHeader(code)
      
      if err := json.NewEncoder(w).Encode(data); err != nil {
          s.logger.Error("failed to encode response",
              slog.Any("error", err),
              slog.String("request_id", middleware.GetReqID(r.Context())),
          )
      }
  }
  
  // Health check handler
  func (s *HTTPServer) handleHealth(w http.ResponseWriter, r *http.Request) {
      health := map[string]interface{}{
          "status":  "healthy",
          "version": ServerVersion,
          "time":    time.Now().UTC(),
      }
      
      s.respondJSON(w, r, http.StatusOK, health)
  }
  ```

- **Configuration Changes:** 
  - Add HTTP server configuration to server config file
  - Configure port, timeouts, and rate limits
  - Add CORS allowed origins configuration

- **Dependencies:**
  - `github.com/go-chi/chi/v5`
  - `github.com/go-chi/chi/v5/middleware`
  - `github.com/go-chi/cors`
  - `github.com/go-chi/httprate`

## 4. Acceptance Criteria
- **Functional Criteria:**
  - HTTP server starts and accepts connections on configured port
  - Health check endpoint returns server status and version
  - Middleware chain processes requests correctly
  - Rate limiting prevents excessive requests
  - Version checking validates client compatibility
  - CORS headers allow CLI HTTP server communication
  
- **Technical Criteria:**
  - Graceful shutdown works with context cancellation
  - Request/response logging includes all relevant fields
  - Error responses follow consistent JSON format
  - Middleware execution order is correct
  - Server timeouts are properly configured
  
- **Integration Criteria:**
  - Works alongside existing MCP server without conflicts
  - Uses same storage layer as MCP tools
  - Logging integrates with existing logger
  
- **Test Criteria:**
  - Server starts and stops cleanly
  - Health endpoint returns 200 OK
  - Rate limiting blocks excessive requests
  - Version mismatch returns 400 error
  - CORS headers are correctly set

## 5. Testing Requirements
- **Unit Tests:**
  - Middleware functions individually tested
  - Version compatibility checking logic
  - Error response formatting
  - Request logging captures correct fields
  - Rate limit counter logic
  
- **Integration Tests:**
  - Full server startup and shutdown
  - Middleware chain execution order
  - Health endpoint with various scenarios
  - CORS preflight request handling
  - Concurrent request handling
  
- **Manual Testing:**
  - Server accessible via curl/Postman
  - Rate limiting behavior verification
  - Version header validation
  - CORS from browser context
  
- **Test Data:**
  - Various version strings for compatibility testing
  - Rate limit test scenarios
  - Invalid request formats

## 6. Definition of Done
- **Code Complete:** HTTP server with all middleware implemented
- **Tests Passing:** All unit and integration tests passing (≥85% coverage)
- **Documentation Updated:** API server setup and configuration documented
- **Integration Verified:** Server runs alongside MCP without conflicts
- **Review Approved:** Code review completed with security considerations

## 7. Dependencies and Blockers
- **Required Sub-Tasks:** None (foundational for MT-003)
- **External Dependencies:** Chi router and middleware libraries
- **Environmental Requirements:** Available port for HTTP server
- **Potential Blockers:** Port conflicts with existing services

## 8. Integration Notes
- **Component Interfaces:** Foundation for all HTTP API endpoints
- **Data Flow:** HTTP requests → Middleware → Handlers → Storage → Response
- **Error Handling:** Consistent error response format across all endpoints
- **Configuration Impact:** New HTTP server configuration section required