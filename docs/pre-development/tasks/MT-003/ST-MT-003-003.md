# ST-MT-003-003: Implement WebSocket Support for Real-Time Updates

## 1. Sub-Task Overview
- **Sub-Task ID:** ST-MT-003-003
- **Sub-Task Name:** Implement WebSocket Support for Real-Time Updates
- **Parent Task:** MT-003: Bidirectional Server Integration and Real-Time Sync
- **Estimated Duration:** 4 hours
- **Implementation Type:** Code

## 2. Deliverable Specification
- **Primary Output:** WebSocket server with real-time task update broadcasting
- **Code Location:** 
  - `internal/adapters/api/websocket/hub.go` - WebSocket connection hub
  - `internal/adapters/api/websocket/client.go` - Client connection handler
  - `internal/adapters/api/websocket/events.go` - Event message types
  - `internal/adapters/api/handlers/websocket_handler.go` - WebSocket upgrade handler
- **Technical Requirements:** Gorilla WebSocket, connection management, event broadcasting
- **Interface Definition:** WebSocket endpoint with JSON event messages

## 3. Implementation Details
- **Step-by-Step Approach:**
  1. Install Gorilla WebSocket library
  2. Create WebSocket hub for connection management
  3. Implement client connection struct and methods
  4. Define event message types and formats
  5. Create WebSocket upgrade handler
  6. Implement connection lifecycle management
  7. Add event broadcasting system
  8. Create task change event publisher
  9. Implement automatic reconnection support
  10. Add connection authentication and validation

- **Code Examples:**
  ```go
  // WebSocket event types
  package websocket
  
  type EventType string
  
  const (
      EventTypeTaskCreated EventType = "task.created"
      EventTypeTaskUpdated EventType = "task.updated"
      EventTypeTaskDeleted EventType = "task.deleted"
      EventTypePing        EventType = "ping"
      EventTypePong        EventType = "pong"
      EventTypeError       EventType = "error"
      EventTypeSubscribe   EventType = "subscribe"
      EventTypeUnsubscribe EventType = "unsubscribe"
  )
  
  type Event struct {
      Type      EventType              `json:"type"`
      Timestamp time.Time              `json:"timestamp"`
      Data      interface{}            `json:"data,omitempty"`
      Error     string                 `json:"error,omitempty"`
  }
  
  type TaskEvent struct {
      TaskID     string                 `json:"task_id"`
      Repository string                 `json:"repository"`
      Task       *models.TaskResponse   `json:"task,omitempty"`
      ChangedBy  string                 `json:"changed_by"`
  }
  
  type SubscribeEvent struct {
      Repositories []string `json:"repositories"`
  }
  
  // WebSocket hub
  type Hub struct {
      clients    map[*Client]bool
      broadcast  chan Event
      register   chan *Client
      unregister chan *Client
      mu         sync.RWMutex
      logger     *slog.Logger
  }
  
  func NewHub(logger *slog.Logger) *Hub {
      return &Hub{
          clients:    make(map[*Client]bool),
          broadcast:  make(chan Event, 256),
          register:   make(chan *Client),
          unregister: make(chan *Client),
          logger:     logger,
      }
  }
  
  func (h *Hub) Run() {
      ticker := time.NewTicker(30 * time.Second)
      defer ticker.Stop()
      
      for {
          select {
          case client := <-h.register:
              h.mu.Lock()
              h.clients[client] = true
              h.mu.Unlock()
              h.logger.Info("client connected",
                  slog.String("client_id", client.id),
                  slog.String("remote_addr", client.remoteAddr))
              
          case client := <-h.unregister:
              h.mu.Lock()
              if _, ok := h.clients[client]; ok {
                  delete(h.clients, client)
                  close(client.send)
                  h.mu.Unlock()
                  h.logger.Info("client disconnected",
                      slog.String("client_id", client.id))
              } else {
                  h.mu.Unlock()
              }
              
          case event := <-h.broadcast:
              h.broadcastEvent(event)
              
          case <-ticker.C:
              // Send ping to all clients
              h.broadcastEvent(Event{
                  Type:      EventTypePing,
                  Timestamp: time.Now(),
              })
          }
      }
  }
  
  func (h *Hub) broadcastEvent(event Event) {
      h.mu.RLock()
      defer h.mu.RUnlock()
      
      for client := range h.clients {
          // Check if client is subscribed to this event
          if h.shouldSendToClient(client, event) {
              select {
              case client.send <- event:
              default:
                  // Client send channel is full, close it
                  close(client.send)
                  delete(h.clients, client)
              }
          }
      }
  }
  
  func (h *Hub) shouldSendToClient(client *Client, event Event) bool {
      // Always send system events
      if event.Type == EventTypePing || event.Type == EventTypeError {
          return true
      }
      
      // For task events, check repository subscription
      if taskEvent, ok := event.Data.(*TaskEvent); ok {
          client.mu.RLock()
          defer client.mu.RUnlock()
          
          // Check if client is subscribed to this repository
          for _, repo := range client.subscribedRepos {
              if repo == "*" || repo == taskEvent.Repository {
                  return true
              }
          }
      }
      
      return false
  }
  
  // WebSocket client
  type Client struct {
      id              string
      hub             *Hub
      conn            *websocket.Conn
      send            chan Event
      subscribedRepos []string
      mu              sync.RWMutex
      remoteAddr      string
      logger          *slog.Logger
  }
  
  const (
      writeWait      = 10 * time.Second
      pongWait       = 60 * time.Second
      pingPeriod     = (pongWait * 9) / 10
      maxMessageSize = 512 * 1024 // 512KB
  )
  
  func NewClient(hub *Hub, conn *websocket.Conn, logger *slog.Logger) *Client {
      return &Client{
          id:              uuid.New().String(),
          hub:             hub,
          conn:            conn,
          send:            make(chan Event, 256),
          subscribedRepos: []string{},
          remoteAddr:      conn.RemoteAddr().String(),
          logger:          logger,
      }
  }
  
  func (c *Client) readPump() {
      defer func() {
          c.hub.unregister <- c
          c.conn.Close()
      }()
      
      c.conn.SetReadLimit(maxMessageSize)
      c.conn.SetReadDeadline(time.Now().Add(pongWait))
      c.conn.SetPongHandler(func(string) error {
          c.conn.SetReadDeadline(time.Now().Add(pongWait))
          return nil
      })
      
      for {
          var event Event
          err := c.conn.ReadJSON(&event)
          if err != nil {
              if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
                  c.logger.Error("websocket error", slog.Any("error", err))
              }
              break
          }
          
          // Handle client events
          switch event.Type {
          case EventTypeSubscribe:
              if subEvent, ok := event.Data.(map[string]interface{}); ok {
                  if repos, ok := subEvent["repositories"].([]interface{}); ok {
                      c.mu.Lock()
                      c.subscribedRepos = make([]string, 0, len(repos))
                      for _, repo := range repos {
                          if r, ok := repo.(string); ok {
                              c.subscribedRepos = append(c.subscribedRepos, r)
                          }
                      }
                      c.mu.Unlock()
                      c.logger.Info("client subscribed",
                          slog.String("client_id", c.id),
                          slog.Any("repositories", c.subscribedRepos))
                  }
              }
              
          case EventTypePong:
              // Client responded to ping
              c.conn.SetReadDeadline(time.Now().Add(pongWait))
          }
      }
  }
  
  func (c *Client) writePump() {
      ticker := time.NewTicker(pingPeriod)
      defer func() {
          ticker.Stop()
          c.conn.Close()
      }()
      
      for {
          select {
          case event, ok := <-c.send:
              c.conn.SetWriteDeadline(time.Now().Add(writeWait))
              if !ok {
                  c.conn.WriteMessage(websocket.CloseMessage, []byte{})
                  return
              }
              
              if err := c.conn.WriteJSON(event); err != nil {
                  return
              }
              
          case <-ticker.C:
              c.conn.SetWriteDeadline(time.Now().Add(writeWait))
              if err := c.conn.WriteMessage(websocket.PingMessage, nil); err != nil {
                  return
              }
          }
      }
  }
  
  // WebSocket handler
  package handlers
  
  var upgrader = websocket.Upgrader{
      ReadBufferSize:  1024,
      WriteBufferSize: 1024,
      CheckOrigin: func(r *http.Request) bool {
          // Allow connections from localhost for CLI
          origin := r.Header.Get("Origin")
          return origin == "" || strings.HasPrefix(origin, "http://localhost")
      },
  }
  
  type WebSocketHandler struct {
      hub    *websocket.Hub
      logger *slog.Logger
  }
  
  func NewWebSocketHandler(hub *websocket.Hub, logger *slog.Logger) *WebSocketHandler {
      return &WebSocketHandler{
          hub:    hub,
          logger: logger,
      }
  }
  
  func (h *WebSocketHandler) HandleWebSocket(w http.ResponseWriter, r *http.Request) {
      // Verify version compatibility
      clientVersion := r.Header.Get("X-Version")
      if clientVersion == "" {
          http.Error(w, "Missing X-Version header", http.StatusBadRequest)
          return
      }
      
      conn, err := upgrader.Upgrade(w, r, nil)
      if err != nil {
          h.logger.Error("websocket upgrade failed", slog.Any("error", err))
          return
      }
      
      client := websocket.NewClient(h.hub, conn, h.logger)
      h.hub.register <- client
      
      // Start client message pumps
      go client.writePump()
      go client.readPump()
  }
  
  // Task event publisher (integrate with storage)
  type TaskEventPublisher struct {
      hub    *websocket.Hub
      logger *slog.Logger
  }
  
  func NewTaskEventPublisher(hub *websocket.Hub, logger *slog.Logger) *TaskEventPublisher {
      return &TaskEventPublisher{
          hub:    hub,
          logger: logger,
      }
  }
  
  func (p *TaskEventPublisher) PublishTaskCreated(task *types.Task) {
      event := Event{
          Type:      websocket.EventTypeTaskCreated,
          Timestamp: time.Now(),
          Data: &websocket.TaskEvent{
              TaskID:     task.ID,
              Repository: task.Repository,
              Task:       convertTaskToResponse(task),
              ChangedBy:  "api",
          },
      }
      
      p.hub.broadcast <- event
  }
  
  func (p *TaskEventPublisher) PublishTaskUpdated(task *types.Task) {
      event := Event{
          Type:      websocket.EventTypeTaskUpdated,
          Timestamp: time.Now(),
          Data: &websocket.TaskEvent{
              TaskID:     task.ID,
              Repository: task.Repository,
              Task:       convertTaskToResponse(task),
              ChangedBy:  "api",
          },
      }
      
      p.hub.broadcast <- event
  }
  
  func (p *TaskEventPublisher) PublishTaskDeleted(taskID, repository string) {
      event := Event{
          Type:      websocket.EventTypeTaskDeleted,
          Timestamp: time.Now(),
          Data: &websocket.TaskEvent{
              TaskID:     taskID,
              Repository: repository,
              ChangedBy:  "api",
          },
      }
      
      p.hub.broadcast <- event
  }
  ```

- **Configuration Changes:** Add WebSocket endpoint configuration
- **Dependencies:**
  - `github.com/gorilla/websocket`

## 4. Acceptance Criteria
- **Functional Criteria:**
  - WebSocket connections establish successfully
  - Real-time events broadcast to connected clients
  - Repository-based subscription filtering works
  - Ping/pong keeps connections alive
  - Task CRUD operations trigger events
  - Clients can subscribe/unsubscribe to repositories
  - Automatic reconnection supported
  
- **Technical Criteria:**
  - Connection management handles disconnects gracefully
  - Event broadcasting scales with multiple clients
  - Memory usage remains stable with many connections
  - Version checking enforced on WebSocket upgrade
  - Origin checking prevents unauthorized connections
  
- **Integration Criteria:**
  - Task events triggered from HTTP API changes
  - MCP tool changes also broadcast events
  - CLI can connect and receive updates
  
- **Test Criteria:**
  - Multiple clients receive same events
  - Subscription filtering works correctly
  - Connection lifecycle properly managed
  - Error events sent appropriately

## 5. Testing Requirements
- **Unit Tests:**
  - Hub client management logic
  - Event filtering by repository
  - Client subscription handling
  - Message serialization
  - Connection state management
  
- **Integration Tests:**
  - WebSocket connection establishment
  - Event broadcasting to multiple clients
  - Task CRUD triggering events
  - Reconnection after disconnect
  - Concurrent connection handling
  
- **Manual Testing:**
  - WebSocket client connection via wscat
  - Real-time updates verification
  - Multiple client scenarios
  - Network interruption recovery
  
- **Test Data:**
  - Various event types and payloads
  - Multiple repository subscriptions
  - Connection stress scenarios

## 6. Definition of Done
- **Code Complete:** WebSocket server with event broadcasting implemented
- **Tests Passing:** Unit and integration tests passing (≥85% coverage)
- **Documentation Updated:** WebSocket protocol and events documented
- **Integration Verified:** Real-time updates work with HTTP API
- **Review Approved:** WebSocket security and performance reviewed

## 7. Dependencies and Blockers
- **Required Sub-Tasks:** ST-MT-003-001 (HTTP Server), ST-MT-003-002 (API endpoints)
- **External Dependencies:** Gorilla WebSocket library
- **Environmental Requirements:** WebSocket-capable network
- **Potential Blockers:** Firewall/proxy WebSocket support

## 8. Integration Notes
- **Component Interfaces:** WebSocket hub integrates with task storage events
- **Data Flow:** Task Change → Event Publisher → Hub → Broadcast → Clients
- **Error Handling:** Connection errors logged, clients notified of issues
- **Configuration Impact:** WebSocket endpoint added to server routes