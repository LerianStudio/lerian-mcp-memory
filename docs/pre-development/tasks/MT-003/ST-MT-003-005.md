# ST-MT-003-005: Implement Batch Operations and Conflict Resolution

## Status
- **Status:** ✅ COMPLETED
- **Completion Date:** 2025-01-09
- **Implementation:** Successfully implemented batch operations with conflict resolution and sync management in `/Users/fredamaral/Repos/lerianstudio/lerian-mcp-memory/internal/`
- **Actual Implementation:** Complete batch sync system with intelligent conflict resolution, Qdrant-based authoritative truth, and comprehensive sync state management
- **Deviations:** Enhanced with sophisticated conflict detection strategies, multi-level resolution algorithms, and advanced sync optimization beyond original scope
- **Next Steps:** None - all features implemented including security fixes for gosec compliance

## IMPLEMENTATION STATUS: ✅ COMPLETED

**What was implemented:**
- ✅ Comprehensive batch operations in `/Users/fredamaral/Repos/lerianstudio/lerian-mcp-memory/internal/bulk/bulk_manager.go`
  - Batch create, update, delete operations with transaction support
  - Batch status transitions and bulk processing
  - Advanced validation and error handling
  - Configurable batch sizes with performance optimization
- ✅ Advanced conflict resolution engine in `/Users/fredamaral/Repos/lerianstudio/lerian-mcp-memory/internal/intelligence/conflict_resolver.go`
  - Multiple resolution strategies (server wins, merge, manual)
  - Conflict type-specific handling for content, status, priority conflicts
  - Confidence scoring and strategy ranking algorithms
  - Architectural, technical, temporal, and outcome conflict types
- ✅ Integrated batch sync service with conflict resolution
- ✅ Qdrant-based conflict resolution using vector storage as authoritative source
- ✅ Batch sync endpoints for client-server synchronization
- ✅ Delta sync optimization for efficient data transfer
- ✅ Sync state tracking and persistence
- ✅ CLI batch sync service integration
- ✅ Advanced sync analytics and performance monitoring
- ✅ Security fixes for gosec compliance (secure batch processing, input validation)

**Implementation Location:**
- Batch operations: `/Users/fredamaral/Repos/lerianstudio/lerian-mcp-memory/internal/bulk/`
- Conflict resolution: `/Users/fredamaral/Repos/lerianstudio/lerian-mcp-memory/internal/intelligence/conflict_resolver.go`
- Sync management: `/Users/fredamaral/Repos/lerianstudio/lerian-mcp-memory/cli/internal/adapters/secondary/sync/`

## 1. Sub-Task Overview
- **Sub-Task ID:** ST-MT-003-005
- **Sub-Task Name:** Implement Batch Operations and Conflict Resolution
- **Parent Task:** MT-003: Bidirectional Server Integration and Real-Time Sync
- **Estimated Duration:** 3 hours
- **Implementation Type:** Code

## 2. Deliverable Specification
- **Primary Output:** Batch sync operations with intelligent conflict resolution using Qdrant as source of truth
- **Code Location:** 
  - `internal/adapters/api/handlers/batch_handlers.go` - Batch API endpoints
  - `internal/domain/services/conflict_resolver.go` - Conflict resolution logic
  - `cli/internal/domain/services/batch_sync.go` - CLI batch sync service
  - `internal/adapters/api/models/batch_models.go` - Batch operation models
- **Technical Requirements:** Efficient batch processing, conflict detection, Qdrant-based resolution
- **Interface Definition:** Batch API endpoints and conflict resolution strategy

## 3. Implementation Details
- **Step-by-Step Approach:**
  1. Create batch operation API models
  2. Implement server batch endpoints for sync
  3. Add conflict detection logic
  4. Create Qdrant-based conflict resolver
  5. Implement CLI batch sync service
  6. Add sync status tracking
  7. Create reconciliation logic
  8. Implement delta sync optimization
  9. Add batch operation rate limiting
  10. Create sync analytics and reporting

- **Code Examples:**
  ```go
  // Batch operation models
  package models
  
  type BatchSyncRequest struct {
      LastSyncTime *time.Time          `json:"last_sync_time"`
      LocalTasks   []TaskSyncItem      `json:"local_tasks"`
      Repository   string              `json:"repository"`
      ClientID     string              `json:"client_id"`
  }
  
  type TaskSyncItem struct {
      ID           string              `json:"id"`
      Content      string              `json:"content"`
      Status       string              `json:"status"`
      Priority     string              `json:"priority"`
      UpdatedAt    time.Time           `json:"updated_at"`
      LocalVersion int                 `json:"local_version"`
      Checksum     string              `json:"checksum"`
  }
  
  type BatchSyncResponse struct {
      ServerTasks    []TaskSyncItem     `json:"server_tasks"`
      Conflicts      []ConflictItem     `json:"conflicts"`
      ToCreate       []string           `json:"to_create"`
      ToUpdate       []string           `json:"to_update"`
      ToDelete       []string           `json:"to_delete"`
      ServerTime     time.Time          `json:"server_time"`
      SyncToken      string             `json:"sync_token"`
  }
  
  type ConflictItem struct {
      TaskID       string              `json:"task_id"`
      LocalTask    *TaskSyncItem       `json:"local_task"`
      ServerTask   *TaskSyncItem       `json:"server_task"`
      Resolution   ConflictResolution  `json:"resolution"`
      Reason       string              `json:"reason"`
  }
  
  type ConflictResolution struct {
      Strategy     string              `json:"strategy"` // "server_wins", "merge", "manual"
      ResolvedTask *TaskSyncItem       `json:"resolved_task"`
  }
  
  // Batch sync handler
  package handlers
  
  type BatchHandlers struct {
      taskStore        storage.TaskStorage
      conflictResolver *services.ConflictResolver
      logger           *slog.Logger
  }
  
  func NewBatchHandlers(taskStore storage.TaskStorage, logger *slog.Logger) *BatchHandlers {
      return &BatchHandlers{
          taskStore:        taskStore,
          conflictResolver: services.NewConflictResolver(taskStore, logger),
          logger:           logger,
      }
  }
  
  // POST /api/v1/batch/sync
  func (h *BatchHandlers) BatchSync(w http.ResponseWriter, r *http.Request) {
      var req models.BatchSyncRequest
      
      if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
          h.respondError(w, r, http.StatusBadRequest, "invalid request body")
          return
      }
      
      ctx := r.Context()
      
      // Get all server tasks for repository
      serverTasks, err := h.taskStore.GetByRepository(ctx, req.Repository, req.LastSyncTime)
      if err != nil {
          h.logger.Error("failed to get server tasks", slog.Any("error", err))
          h.respondError(w, r, http.StatusInternalServerError, "sync failed")
          return
      }
      
      // Build sync response
      response := h.buildSyncResponse(req, serverTasks)
      
      // Apply batch operations if requested
      if r.URL.Query().Get("apply") == "true" {
          if err := h.applyBatchOperations(ctx, req, response); err != nil {
              h.logger.Error("failed to apply batch operations", slog.Any("error", err))
              h.respondError(w, r, http.StatusInternalServerError, "batch apply failed")
              return
          }
      }
      
      h.respondJSON(w, r, http.StatusOK, response)
  }
  
  func (h *BatchHandlers) buildSyncResponse(req models.BatchSyncRequest, serverTasks []*types.Task) models.BatchSyncResponse {
      response := models.BatchSyncResponse{
          ServerTasks: make([]models.TaskSyncItem, 0),
          Conflicts:   make([]models.ConflictItem, 0),
          ToCreate:    make([]string, 0),
          ToUpdate:    make([]string, 0),
          ToDelete:    make([]string, 0),
          ServerTime:  time.Now(),
          SyncToken:   generateSyncToken(),
      }
      
      // Create maps for efficient lookup
      localMap := make(map[string]models.TaskSyncItem)
      for _, task := range req.LocalTasks {
          localMap[task.ID] = task
      }
      
      serverMap := make(map[string]*types.Task)
      for _, task := range serverTasks {
          serverMap[task.ID] = task
          
          // Add to response
          response.ServerTasks = append(response.ServerTasks, h.taskToSyncItem(task))
      }
      
      // Detect operations needed
      for _, localTask := range req.LocalTasks {
          serverTask, exists := serverMap[localTask.ID]
          
          if !exists {
              // Local task doesn't exist on server
              response.ToCreate = append(response.ToCreate, localTask.ID)
          } else if h.hasConflict(localTask, serverTask) {
              // Conflict detected
              conflict := h.conflictResolver.DetectConflict(localTask, serverTask)
              response.Conflicts = append(response.Conflicts, conflict)
          } else if localTask.UpdatedAt.After(serverTask.UpdatedAt) {
              // Local is newer, update server
              response.ToUpdate = append(response.ToUpdate, localTask.ID)
          }
      }
      
      // Check for server tasks not in local
      for _, serverTask := range serverTasks {
          if _, exists := localMap[serverTask.ID]; !exists {
              response.ToDelete = append(response.ToDelete, serverTask.ID)
          }
      }
      
      return response
  }
  
  // Conflict resolver service
  package services
  
  type ConflictResolver struct {
      qdrantStore storage.VectorStorage
      logger      *slog.Logger
  }
  
  func NewConflictResolver(qdrantStore storage.VectorStorage, logger *slog.Logger) *ConflictResolver {
      return &ConflictResolver{
          qdrantStore: qdrantStore,
          logger:      logger,
      }
  }
  
  func (r *ConflictResolver) ResolveConflict(local, server models.TaskSyncItem) models.ConflictResolution {
      // Strategy 1: Check Qdrant for authoritative version
      qdrantTask, err := r.qdrantStore.GetTask(local.ID)
      if err != nil {
          r.logger.Warn("qdrant lookup failed, using server version", 
              slog.String("task_id", local.ID),
              slog.Any("error", err))
          
          return models.ConflictResolution{
              Strategy:     "server_wins",
              ResolvedTask: &server,
          }
      }
      
      // Compare checksums to find truth
      if qdrantTask.Checksum == server.Checksum {
          // Server matches Qdrant - server is truth
          return models.ConflictResolution{
              Strategy:     "server_wins",
              ResolvedTask: &server,
          }
      }
      
      if qdrantTask.Checksum == local.Checksum {
          // Local matches Qdrant - unusual but possible
          return models.ConflictResolution{
              Strategy:     "local_wins",
              ResolvedTask: &local,
          }
      }
      
      // Neither matches Qdrant - merge based on timestamps
      if server.UpdatedAt.After(local.UpdatedAt) {
          return models.ConflictResolution{
              Strategy:     "server_wins_newer",
              ResolvedTask: &server,
          }
      }
      
      // Attempt content merge for same timestamp
      if server.UpdatedAt.Equal(local.UpdatedAt) {
          merged := r.mergeTaskContent(local, server)
          return models.ConflictResolution{
              Strategy:     "merge",
              ResolvedTask: merged,
          }
      }
      
      // Default to server
      return models.ConflictResolution{
          Strategy:     "server_wins_default",
          ResolvedTask: &server,
      }
  }
  
  func (r *ConflictResolver) mergeTaskContent(local, server models.TaskSyncItem) *models.TaskSyncItem {
      // Simple merge strategy - combine unique changes
      merged := server // Start with server as base
      
      // If status differs and local is more advanced, use local
      if local.Status != server.Status && r.isStatusProgression(server.Status, local.Status) {
          merged.Status = local.Status
      }
      
      // If priority differs and local is higher, use local
      if local.Priority != server.Priority && r.isPriorityHigher(local.Priority, server.Priority) {
          merged.Priority = local.Priority
      }
      
      // Content merge - if significantly different, append local changes
      if local.Content != server.Content {
          // Check if local has additional content
          if len(local.Content) > len(server.Content) && 
             strings.HasPrefix(local.Content, server.Content) {
              merged.Content = local.Content
          }
      }
      
      merged.UpdatedAt = time.Now()
      return &merged
  }
  
  // CLI batch sync service
  package services
  
  type BatchSyncService struct {
      httpClient   *api.HTTPClient
      localStorage storage.TaskStorage
      syncState    *SyncState
      logger       *slog.Logger
      mu           sync.Mutex
  }
  
  type SyncState struct {
      LastSyncTime   time.Time          `json:"last_sync_time"`
      SyncToken      string             `json:"sync_token"`
      PendingChanges int                `json:"pending_changes"`
      Repository     string             `json:"repository"`
  }
  
  func NewBatchSyncService(httpClient *api.HTTPClient, localStorage storage.TaskStorage, logger *slog.Logger) *BatchSyncService {
      return &BatchSyncService{
          httpClient:   httpClient,
          localStorage: localStorage,
          syncState:    &SyncState{},
          logger:       logger,
      }
  }
  
  func (s *BatchSyncService) PerformSync(ctx context.Context, repository string) error {
      s.mu.Lock()
      defer s.mu.Unlock()
      
      // Get local tasks modified since last sync
      localTasks, err := s.localStorage.GetModifiedSince(ctx, s.syncState.LastSyncTime, repository)
      if err != nil {
          return fmt.Errorf("failed to get local tasks: %w", err)
      }
      
      // Build sync request
      syncItems := make([]models.TaskSyncItem, 0, len(localTasks))
      for _, task := range localTasks {
          syncItems = append(syncItems, s.taskToSyncItem(task))
      }
      
      req := models.BatchSyncRequest{
          LastSyncTime: &s.syncState.LastSyncTime,
          LocalTasks:   syncItems,
          Repository:   repository,
          ClientID:     s.getClientID(),
      }
      
      // Perform sync
      resp, err := s.httpClient.BatchSync(ctx, &req)
      if err != nil {
          return fmt.Errorf("batch sync failed: %w", err)
      }
      
      // Apply sync results
      if err := s.applySyncResults(ctx, resp); err != nil {
          return fmt.Errorf("failed to apply sync results: %w", err)
      }
      
      // Update sync state
      s.syncState.LastSyncTime = resp.ServerTime
      s.syncState.SyncToken = resp.SyncToken
      s.syncState.Repository = repository
      
      s.logger.Info("batch sync completed",
          slog.Int("conflicts", len(resp.Conflicts)),
          slog.Int("created", len(resp.ToCreate)),
          slog.Int("updated", len(resp.ToUpdate)),
          slog.Int("deleted", len(resp.ToDelete)))
      
      return nil
  }
  
  func (s *BatchSyncService) applySyncResults(ctx context.Context, resp *models.BatchSyncResponse) error {
      // Handle conflicts first
      for _, conflict := range resp.Conflicts {
          if conflict.Resolution.ResolvedTask != nil {
              task := s.syncItemToTask(conflict.Resolution.ResolvedTask)
              if err := s.localStorage.Update(ctx, task); err != nil {
                  s.logger.Error("failed to apply conflict resolution",
                      slog.String("task_id", task.ID),
                      slog.Any("error", err))
              }
          }
      }
      
      // Apply server changes
      for _, serverTask := range resp.ServerTasks {
          task := s.syncItemToTask(&serverTask)
          
          // Check if we need to create or update
          existing, err := s.localStorage.GetByID(ctx, task.ID)
          if err != nil {
              // Create new
              if err := s.localStorage.Create(ctx, task); err != nil {
                  s.logger.Error("failed to create task from server",
                      slog.String("task_id", task.ID),
                      slog.Any("error", err))
              }
          } else if task.UpdatedAt.After(existing.UpdatedAt) {
              // Update existing
              if err := s.localStorage.Update(ctx, task); err != nil {
                  s.logger.Error("failed to update task from server",
                      slog.String("task_id", task.ID),
                      slog.Any("error", err))
              }
          }
      }
      
      // Delete tasks that don't exist on server
      for _, taskID := range resp.ToDelete {
          if err := s.localStorage.Delete(ctx, taskID); err != nil {
              s.logger.Error("failed to delete local task",
                  slog.String("task_id", taskID),
                  slog.Any("error", err))
          }
      }
      
      return nil
  }
  
  // Add batch endpoint to routes
  func RegisterBatchRoutes(r chi.Router, handlers *handlers.BatchHandlers) {
      r.Route("/batch", func(r chi.Router) {
          r.Post("/sync", handlers.BatchSync)
      })
  }
  ```

- **Configuration Changes:** 
  - Add sync interval configuration
  - Configure conflict resolution strategy
  - Add batch size limits

- **Dependencies:** None beyond existing

## 4. Acceptance Criteria
- **Functional Criteria:**
  - Batch sync efficiently handles multiple task changes
  - Conflicts detected based on checksums and timestamps
  - Qdrant used as authoritative source for conflicts
  - Merge strategy handles common conflict scenarios
  - Delta sync minimizes data transfer
  - Sync state persists between sessions
  - Analytics track sync performance
  
- **Technical Criteria:**
  - Batch operations complete within reasonable time
  - Conflict resolution is deterministic
  - Memory efficient for large batches
  - Sync token prevents duplicate operations
  - Rate limiting prevents server overload
  
- **Integration Criteria:**
  - Works with real-time WebSocket updates
  - Integrates with local storage layer
  - Compatible with MCP tool changes
  
- **Test Criteria:**
  - Various conflict scenarios resolved correctly
  - Large batch operations handled
  - Network interruption recovery
  - Sync state persistence

## 5. Testing Requirements
- **Unit Tests:**
  - Conflict detection logic
  - Resolution strategies
  - Merge algorithms
  - Sync state management
  - Checksum calculations
  
- **Integration Tests:**
  - Full batch sync flow
  - Conflict resolution with Qdrant
  - Multiple client sync scenarios
  - Delta sync optimization
  - Sync recovery after failure
  
- **Manual Testing:**
  - Create conflicts manually
  - Large batch sync performance
  - Multiple repository sync
  - Sync analytics accuracy
  
- **Test Data:**
  - Conflicting task modifications
  - Large task datasets
  - Various conflict scenarios

## 6. Definition of Done
- **Code Complete:** Batch operations and conflict resolution implemented
- **Tests Passing:** All sync scenarios tested (≥85% coverage)
- **Documentation Updated:** Sync behavior and conflict resolution documented
- **Integration Verified:** Works with entire sync system
- **Review Approved:** Conflict resolution logic and performance reviewed

## 7. Dependencies and Blockers
- **Required Sub-Tasks:** All previous MT-003 sub-tasks
- **External Dependencies:** Access to Qdrant for conflict resolution
- **Environmental Requirements:** None specific
- **Potential Blockers:** Qdrant performance for conflict checks

## 8. Integration Notes
- **Component Interfaces:** Integrates with HTTP API, WebSocket, and storage
- **Data Flow:** Local Changes → Batch Sync → Conflict Resolution → Apply Results
- **Error Handling:** Partial sync success with detailed error reporting
- **Configuration Impact:** Sync interval and batch size configuration