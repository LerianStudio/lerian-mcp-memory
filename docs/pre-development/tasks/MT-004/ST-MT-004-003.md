# ST-MT-004-003: Create Template System with Project Type Recognition

## 1. Sub-Task Overview
- **Sub-Task ID:** ST-MT-004-003
- **Sub-Task Name:** Create Template System with Project Type Recognition
- **Parent Task:** MT-004: Intelligence Features and Pattern Learning
- **Estimated Duration:** 3 hours
- **Implementation Type:** Code

## 2. Deliverable Specification
- **Primary Output:** Template management system with intelligent project type detection and task template generation
- **Code Location:** 
  - `cli/internal/domain/entities/templates.go` - Template entities
  - `cli/internal/domain/services/template_service.go` - Template service
  - `cli/internal/domain/services/project_classifier.go` - Project type classifier
  - `cli/internal/adapters/secondary/templates/repository.go` - Template storage
  - `cli/internal/adapters/secondary/templates/defaults/` - Built-in templates
- **Technical Requirements:** Template engine, project classification, template matching, customization support
- **Interface Definition:** TemplateService interface, ProjectClassifier interface, template format specification

## 3. Implementation Details
- **Step-by-Step Approach:**
  1. Create template entity structures with metadata
  2. Define built-in templates for common project types
  3. Implement project type classifier using file analysis
  4. Create template service with CRUD operations
  5. Add template matching based on project characteristics
  6. Implement template customization and extension
  7. Create template instantiation with variable substitution
  8. Add template versioning and updates
  9. Implement template sharing capabilities
  10. Create template validation and testing

- **Code Examples:**
  ```go
  // Template entities
  package entities
  
  type ProjectType string
  
  const (
      ProjectTypeWebApp     ProjectType = "web_app"
      ProjectTypeCLI        ProjectType = "cli"
      ProjectTypeAPI        ProjectType = "api"
      ProjectTypeLibrary    ProjectType = "library"
      ProjectTypeMicroservice ProjectType = "microservice"
      ProjectTypeDataPipeline ProjectType = "data_pipeline"
      ProjectTypeMobile     ProjectType = "mobile"
      ProjectTypeUnknown    ProjectType = "unknown"
  )
  
  type TaskTemplate struct {
      ID              string                 `json:"id" validate:"required,uuid"`
      Name            string                 `json:"name" validate:"required,min=1,max=200"`
      Description     string                 `json:"description"`
      ProjectType     ProjectType            `json:"project_type" validate:"required"`
      Category        string                 `json:"category"`        // "initialization", "feature", "maintenance"
      Version         string                 `json:"version"`
      Author          string                 `json:"author"`
      Tasks           []TemplateTask         `json:"tasks" validate:"required,min=1"`
      Variables       []TemplateVariable     `json:"variables"`
      Prerequisites   []string               `json:"prerequisites"`    // Other template IDs
      Tags            []string               `json:"tags"`
      Metadata        map[string]interface{} `json:"metadata"`
      UsageCount      int                    `json:"usage_count"`
      SuccessRate     float64                `json:"success_rate"`
      LastUsed        *time.Time             `json:"last_used,omitempty"`
      CreatedAt       time.Time              `json:"created_at"`
      UpdatedAt       time.Time              `json:"updated_at"`
      IsBuiltIn       bool                   `json:"is_built_in"`
      IsPublic        bool                   `json:"is_public"`
  }
  
  type TemplateTask struct {
      Order           int                    `json:"order"`
      Content         string                 `json:"content" validate:"required"`
      Priority        string                 `json:"priority"`
      EstimatedHours  float64                `json:"estimated_hours"`
      Dependencies    []int                  `json:"dependencies"`     // Orders of dependent tasks
      Tags            []string               `json:"tags"`
      Metadata        map[string]interface{} `json:"metadata"`
  }
  
  type TemplateVariable struct {
      Name            string                 `json:"name" validate:"required"`
      Description     string                 `json:"description"`
      Type            string                 `json:"type"`            // "string", "number", "boolean", "choice"
      Default         interface{}            `json:"default"`
      Required        bool                   `json:"required"`
      Options         []string               `json:"options,omitempty"` // For choice type
      ValidationRegex string                 `json:"validation_regex,omitempty"`
  }
  
  // Project classifier
  type ProjectClassifier interface {
      ClassifyProject(ctx context.Context, path string) (ProjectType, float64, error)
      GetProjectCharacteristics(ctx context.Context, path string) (*ProjectCharacteristics, error)
      SuggestProjectType(characteristics *ProjectCharacteristics) (ProjectType, float64)
  }
  
  type ProjectCharacteristics struct {
      Languages       map[string]int         `json:"languages"`        // Language -> file count
      Frameworks      []string               `json:"frameworks"`
      Dependencies    []string               `json:"dependencies"`
      FilePatterns    map[string]int         `json:"file_patterns"`    // Pattern -> count
      HasTests        bool                   `json:"has_tests"`
      HasCI           bool                   `json:"has_ci"`
      HasDocker       bool                   `json:"has_docker"`
      HasDatabase     bool                   `json:"has_database"`
      HasAPI          bool                   `json:"has_api"`
      HasFrontend     bool                   `json:"has_frontend"`
      DirectoryDepth  int                    `json:"directory_depth"`
      TotalFiles      int                    `json:"total_files"`
      Metadata        map[string]interface{} `json:"metadata"`
  }
  
  type projectClassifierImpl struct {
      fileAnalyzer FileAnalyzer
      logger       *slog.Logger
  }
  
  func (c *projectClassifierImpl) ClassifyProject(
      ctx context.Context, 
      path string,
  ) (ProjectType, float64, error) {
      // Analyze project structure
      characteristics, err := c.GetProjectCharacteristics(ctx, path)
      if err != nil {
          return ProjectTypeUnknown, 0, err
      }
      
      // Apply classification rules
      projectType, confidence := c.SuggestProjectType(characteristics)
      
      return projectType, confidence, nil
  }
  
  func (c *projectClassifierImpl) SuggestProjectType(
      chars *ProjectCharacteristics,
  ) (ProjectType, float64) {
      scores := make(map[ProjectType]float64)
      
      // Web App indicators
      if chars.HasFrontend && (chars.HasAPI || chars.HasBackend()) {
          scores[ProjectTypeWebApp] += 0.8
      }
      if chars.HasFramework("react", "vue", "angular", "next", "nuxt") {
          scores[ProjectTypeWebApp] += 0.2
      }
      
      // CLI indicators
      if chars.HasMainFile() && !chars.HasFrontend && !chars.HasAPI {
          scores[ProjectTypeCLI] += 0.7
      }
      if chars.HasFramework("cobra", "cli", "commander") {
          scores[ProjectTypeCLI] += 0.3
      }
      
      // API indicators
      if chars.HasAPI && !chars.HasFrontend {
          scores[ProjectTypeAPI] += 0.8
      }
      if chars.HasFramework("express", "fastapi", "gin", "echo") {
          scores[ProjectTypeAPI] += 0.2
      }
      
      // Microservice indicators
      if chars.HasDocker && chars.HasAPI && chars.DirectoryDepth <= 3 {
          scores[ProjectTypeMicroservice] += 0.7
      }
      if chars.HasKubernetes() || chars.HasServiceMesh() {
          scores[ProjectTypeMicroservice] += 0.3
      }
      
      // Find highest score
      var bestType ProjectType = ProjectTypeUnknown
      var bestScore float64 = 0
      
      for pType, score := range scores {
          if score > bestScore {
              bestType = pType
              bestScore = score
          }
      }
      
      return bestType, bestScore
  }
  
  // Template service
  type TemplateService interface {
      ListTemplates(ctx context.Context, projectType ProjectType) ([]*TaskTemplate, error)
      GetTemplate(ctx context.Context, templateID string) (*TaskTemplate, error)
      CreateTemplate(ctx context.Context, template *TaskTemplate) error
      InstantiateTemplate(ctx context.Context, templateID string, vars map[string]interface{}) ([]*Task, error)
      MatchTemplates(ctx context.Context, projectPath string) ([]*TemplateMatch, error)
      GetBuiltInTemplates() []*TaskTemplate
      UpdateTemplateUsage(ctx context.Context, templateID string, success bool) error
  }
  
  type TemplateMatch struct {
      Template   *TaskTemplate `json:"template"`
      Score      float64       `json:"score"`      // Match score 0-1
      Reason     string        `json:"reason"`     // Why this template matches
  }
  
  type templateServiceImpl struct {
      templateStore    storage.TemplateStorage
      projectClassifier ProjectClassifier
      taskStore        storage.TaskStorage
      builtInTemplates map[string]*TaskTemplate
      logger           *slog.Logger
  }
  
  func NewTemplateService(deps TemplateDeps) TemplateService {
      service := &templateServiceImpl{
          templateStore:     deps.TemplateStore,
          projectClassifier: deps.ProjectClassifier,
          taskStore:         deps.TaskStore,
          logger:            deps.Logger,
          builtInTemplates:  make(map[string]*TaskTemplate),
      }
      
      // Load built-in templates
      service.loadBuiltInTemplates()
      
      return service
  }
  
  func (s *templateServiceImpl) loadBuiltInTemplates() {
      // Web App template
      webAppTemplate := &TaskTemplate{
          ID:          "builtin-web-app-init",
          Name:        "Web Application Setup",
          Description: "Complete setup for a modern web application",
          ProjectType: ProjectTypeWebApp,
          Category:    "initialization",
          Version:     "1.0.0",
          Author:      "system",
          IsBuiltIn:   true,
          IsPublic:    true,
          Tasks: []TemplateTask{
              {
                  Order:          1,
                  Content:        "Setup project structure and initial configuration",
                  Priority:       "high",
                  EstimatedHours: 2,
                  Tags:           []string{"setup", "config"},
              },
              {
                  Order:          2,
                  Content:        "Configure {{.Framework}} framework with TypeScript",
                  Priority:       "high",
                  EstimatedHours: 3,
                  Dependencies:   []int{1},
                  Tags:           []string{"framework", "typescript"},
              },
              {
                  Order:          3,
                  Content:        "Setup {{.Database}} database and ORM",
                  Priority:       "high",
                  EstimatedHours: 2,
                  Dependencies:   []int{1},
                  Tags:           []string{"database", "backend"},
              },
              {
                  Order:          4,
                  Content:        "Implement authentication system",
                  Priority:       "high",
                  EstimatedHours: 4,
                  Dependencies:   []int{2, 3},
                  Tags:           []string{"auth", "security"},
              },
              {
                  Order:          5,
                  Content:        "Create initial UI components and layouts",
                  Priority:       "medium",
                  EstimatedHours: 3,
                  Dependencies:   []int{2},
                  Tags:           []string{"ui", "frontend"},
              },
              {
                  Order:          6,
                  Content:        "Setup testing framework and write initial tests",
                  Priority:       "medium",
                  EstimatedHours: 2,
                  Dependencies:   []int{2, 3},
                  Tags:           []string{"testing", "quality"},
              },
          },
          Variables: []TemplateVariable{
              {
                  Name:        "Framework",
                  Description: "Frontend framework to use",
                  Type:        "choice",
                  Default:     "react",
                  Required:    true,
                  Options:     []string{"react", "vue", "angular", "svelte"},
              },
              {
                  Name:        "Database",
                  Description: "Database system to use",
                  Type:        "choice",
                  Default:     "postgresql",
                  Required:    true,
                  Options:     []string{"postgresql", "mysql", "mongodb", "sqlite"},
              },
          },
      }
      
      s.builtInTemplates[webAppTemplate.ID] = webAppTemplate
      
      // Add more built-in templates...
  }
  
  func (s *templateServiceImpl) InstantiateTemplate(
      ctx context.Context,
      templateID string,
      vars map[string]interface{},
  ) ([]*Task, error) {
      // Get template
      template, err := s.GetTemplate(ctx, templateID)
      if err != nil {
          return nil, err
      }
      
      // Validate variables
      if err := s.validateVariables(template, vars); err != nil {
          return nil, err
      }
      
      // Apply defaults for missing variables
      vars = s.applyDefaults(template, vars)
      
      // Create tasks from template
      var tasks []*Task
      taskMap := make(map[int]*Task) // For dependency resolution
      
      for _, tmplTask := range template.Tasks {
          // Substitute variables in content
          content := s.substituteVariables(tmplTask.Content, vars)
          
          task := &Task{
              ID:          uuid.New().String(),
              Content:     content,
              Status:      "pending",
              Priority:    tmplTask.Priority,
              Repository:  vars["repository"].(string),
              CreatedAt:   time.Now(),
              UpdatedAt:   time.Now(),
              Metadata: map[string]interface{}{
                  "template_id":     template.ID,
                  "template_order":  tmplTask.Order,
                  "estimated_hours": tmplTask.EstimatedHours,
                  "tags":            tmplTask.Tags,
              },
          }
          
          tasks = append(tasks, task)
          taskMap[tmplTask.Order] = task
      }
      
      // Set dependencies
      for i, tmplTask := range template.Tasks {
          for _, depOrder := range tmplTask.Dependencies {
              if depTask, exists := taskMap[depOrder]; exists {
                  tasks[i].Metadata["depends_on"] = append(
                      tasks[i].Metadata["depends_on"].([]string),
                      depTask.ID,
                  )
              }
          }
      }
      
      // Store tasks
      for _, task := range tasks {
          if err := s.taskStore.Create(ctx, task); err != nil {
              return nil, fmt.Errorf("failed to create task: %w", err)
          }
      }
      
      // Update template usage
      s.UpdateTemplateUsage(ctx, templateID, true)
      
      return tasks, nil
  }
  ```

- **Configuration Changes:** 
  - Add template directory configuration
  - Configure project type detection rules
  - Set template matching thresholds

- **Dependencies:**
  - File analysis utilities for project classification
  - Template engine for variable substitution

## 4. Acceptance Criteria
- **Functional Criteria:**
  - Project type detection accuracy >80%
  - Templates cover major project types (web, CLI, API, etc.)
  - Variable substitution works correctly
  - Template matching suggests relevant templates
  - Custom templates can be created and used
  - Template versioning tracks changes
  - Usage statistics updated correctly
  
- **Technical Criteria:**
  - Project classification completes in <2 seconds
  - Template instantiation is atomic (all or nothing)
  - Built-in templates load on startup
  - Template storage is efficient
  
- **Integration Criteria:**
  - Works with task creation system
  - Integrates with suggestion service
  - Compatible with workflow automation
  
- **Test Criteria:**
  - Project classification tested on various projects
  - Template instantiation validated
  - Variable validation works correctly
  - Dependency resolution tested

## 5. Testing Requirements
- **Unit Tests:**
  - Project classification logic
  - Template variable substitution
  - Dependency resolution
  - Variable validation
  - Template matching algorithm
  - Built-in template loading
  
- **Integration Tests:**
  - Full template instantiation flow
  - Project type detection with real projects
  - Template storage and retrieval
  - Usage statistics updates
  
- **Manual Testing:**
  - Test templates on real projects
  - Verify project type detection accuracy
  - Check template quality
  - Validate generated tasks
  
- **Test Data:**
  - Sample projects of various types
  - Template test cases
  - Variable substitution scenarios
  - Invalid template configurations

## 6. Definition of Done
- **Code Complete:** Template system with project classification implemented
- **Tests Passing:** All unit and integration tests passing (≥85% coverage)
- **Documentation Updated:** Template format documented, usage guides created
- **Integration Verified:** Works with task management and suggestions
- **Review Approved:** Code review including template quality review

## 7. Dependencies and Blockers
- **Required Sub-Tasks:** None (can work independently)
- **External Dependencies:** File system access for project analysis
- **Environmental Requirements:** Go 1.23+ development environment
- **Potential Blockers:** Complex project structures may be hard to classify

## 8. Integration Notes
- **Component Interfaces:** Used by CLI init command and suggestion service
- **Data Flow:** Project Analysis → Classification → Template Matching → Instantiation
- **Error Handling:** Graceful handling of unknown project types
- **Configuration Impact:** New template configuration section