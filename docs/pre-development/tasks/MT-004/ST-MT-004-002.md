# ST-MT-004-002: Implement Task Suggestion Service with Context Analysis

## 1. Sub-Task Overview
- **Sub-Task ID:** ST-MT-004-002
- **Sub-Task Name:** Implement Task Suggestion Service with Context Analysis
- **Parent Task:** MT-004: Intelligence Features and Pattern Learning
- **Estimated Duration:** 4 hours
- **Implementation Type:** Code

## 2. Deliverable Specification
- **Primary Output:** AI-powered task suggestion service with contextual analysis and ranking
- **Code Location:** 
  - `cli/internal/domain/services/suggestion_service.go` - Main suggestion service
  - `cli/internal/domain/services/context_analyzer.go` - Context analysis engine
  - `cli/internal/adapters/secondary/ai/suggestion_engine.go` - AI suggestion integration
  - `cli/internal/domain/entities/suggestions.go` - Suggestion entities
- **Technical Requirements:** Context analysis, AI integration, suggestion ranking, relevance scoring
- **Interface Definition:** SuggestionService interface, ContextAnalyzer interface, ranking algorithms

## 3. Implementation Details
- **Step-by-Step Approach:**
  1. Create suggestion entity structures with metadata
  2. Implement context analyzer for current work state
  3. Create suggestion service interface and implementation
  4. Integrate with pattern detection engine from ST-MT-004-001
  5. Add AI-powered suggestion generation
  6. Implement suggestion ranking algorithm
  7. Create relevance scoring based on context
  8. Add caching for frequently suggested tasks
  9. Implement feedback mechanism for suggestion improvement
  10. Create suggestion persistence layer

- **Code Examples:**
  ```go
  // Suggestion entities
  package entities
  
  type SuggestionType string
  
  const (
      SuggestionTypeNext       SuggestionType = "next_task"
      SuggestionTypeRelated    SuggestionType = "related"
      SuggestionTypeOptimize   SuggestionType = "optimization"
      SuggestionTypeTemplate   SuggestionType = "template"
      SuggestionTypeLearning   SuggestionType = "learning"
  )
  
  type TaskSuggestion struct {
      ID              string                 `json:"id" validate:"required,uuid"`
      Type            SuggestionType         `json:"type" validate:"required"`
      Content         string                 `json:"content" validate:"required,min=1,max=1000"`
      Description     string                 `json:"description"`
      Priority        string                 `json:"priority"`
      EstimatedTime   time.Duration          `json:"estimated_time"`
      Confidence      float64                `json:"confidence"`      // 0-1 confidence score
      Relevance       float64                `json:"relevance"`       // 0-1 relevance to current context
      Source          SuggestionSource       `json:"source"`
      PatternID       string                 `json:"pattern_id,omitempty"`
      Keywords        []string               `json:"keywords"`
      Prerequisites   []string               `json:"prerequisites"`   // Task IDs that should be completed first
      Metadata        map[string]interface{} `json:"metadata"`
      GeneratedAt     time.Time              `json:"generated_at"`
      ExpiresAt       time.Time              `json:"expires_at"`
      UserFeedback    *SuggestionFeedback    `json:"feedback,omitempty"`
  }
  
  type SuggestionSource struct {
      Type        string `json:"type"`        // "pattern", "ai", "template", "history"
      Name        string `json:"name"`        // Source identifier
      Confidence  float64 `json:"confidence"`  // Source-specific confidence
  }
  
  type SuggestionFeedback struct {
      Accepted    bool      `json:"accepted"`
      Helpful     bool      `json:"helpful"`
      Rating      int       `json:"rating,omitempty"` // 1-5 stars
      Comment     string    `json:"comment,omitempty"`
      ProvidedAt  time.Time `json:"provided_at"`
  }
  
  // Context analyzer
  type WorkContext struct {
      CurrentTasks     []*Task               `json:"current_tasks"`
      RecentTasks      []*Task               `json:"recent_tasks"`      // Last 10 completed
      Repository       string                `json:"repository"`
      ProjectType      string                `json:"project_type"`
      CurrentSession   *Session              `json:"current_session"`
      TimeOfDay        string                `json:"time_of_day"`       // morning, afternoon, evening
      DayOfWeek        string                `json:"day_of_week"`
      WorkingHours     *WorkingHours         `json:"working_hours"`
      RecentPatterns   []*TaskPattern        `json:"recent_patterns"`
      Velocity         float64               `json:"velocity"`          // Tasks/hour
      FocusLevel       float64               `json:"focus_level"`       // 0-1 based on interruptions
  }
  
  type ContextAnalyzer interface {
      AnalyzeCurrentContext(ctx context.Context, repository string) (*WorkContext, error)
      ExtractKeywords(tasks []*Task) []string
      DetermineProjectType(ctx context.Context, repository string) (string, error)
      CalculateFocusLevel(session *Session) float64
      PredictOptimalTaskType(context *WorkContext) string
  }
  
  // Suggestion service
  type SuggestionService interface {
      GenerateSuggestions(ctx context.Context, repository string) ([]*TaskSuggestion, error)
      GetNextTaskSuggestion(ctx context.Context, currentTask *Task) (*TaskSuggestion, error)
      GetRelatedSuggestions(ctx context.Context, task *Task, limit int) ([]*TaskSuggestion, error)
      GetWorkflowSuggestions(ctx context.Context, projectType string) ([]*TaskSuggestion, error)
      ProvideFeedback(ctx context.Context, suggestionID string, feedback *SuggestionFeedback) error
      GetSuggestionHistory(ctx context.Context, repository string) ([]*TaskSuggestion, error)
  }
  
  type suggestionServiceImpl struct {
      contextAnalyzer  ContextAnalyzer
      patternDetector  PatternDetector
      aiService        AIService
      templateService  TemplateService
      taskStore        storage.TaskStorage
      suggestionStore  storage.SuggestionStorage
      cache            cache.Cache
      logger           *slog.Logger
  }
  
  func NewSuggestionService(deps SuggestionDeps) SuggestionService {
      return &suggestionServiceImpl{
          contextAnalyzer:  deps.ContextAnalyzer,
          patternDetector:  deps.PatternDetector,
          aiService:        deps.AIService,
          templateService:  deps.TemplateService,
          taskStore:        deps.TaskStore,
          suggestionStore:  deps.SuggestionStore,
          cache:            deps.Cache,
          logger:           deps.Logger,
      }
  }
  
  func (s *suggestionServiceImpl) GenerateSuggestions(
      ctx context.Context, 
      repository string,
  ) ([]*TaskSuggestion, error) {
      // Analyze current context
      context, err := s.contextAnalyzer.AnalyzeCurrentContext(ctx, repository)
      if err != nil {
          return nil, fmt.Errorf("context analysis failed: %w", err)
      }
      
      // Check cache first
      cacheKey := fmt.Sprintf("suggestions:%s:%s", repository, context.Hash())
      if cached, found := s.cache.Get(cacheKey); found {
          return cached.([]*TaskSuggestion), nil
      }
      
      // Generate suggestions from multiple sources
      var suggestions []*TaskSuggestion
      
      // 1. Pattern-based suggestions
      patternSuggestions, err := s.generatePatternSuggestions(ctx, context)
      if err != nil {
          s.logger.Warn("pattern suggestions failed", slog.Any("error", err))
      } else {
          suggestions = append(suggestions, patternSuggestions...)
      }
      
      // 2. AI-powered suggestions
      aiSuggestions, err := s.generateAISuggestions(ctx, context)
      if err != nil {
          s.logger.Warn("AI suggestions failed", slog.Any("error", err))
      } else {
          suggestions = append(suggestions, aiSuggestions...)
      }
      
      // 3. Template-based suggestions
      templateSuggestions, err := s.generateTemplateSuggestions(ctx, context)
      if err != nil {
          s.logger.Warn("template suggestions failed", slog.Any("error", err))
      } else {
          suggestions = append(suggestions, templateSuggestions...)
      }
      
      // 4. Historical suggestions
      historicalSuggestions, err := s.generateHistoricalSuggestions(ctx, context)
      if err != nil {
          s.logger.Warn("historical suggestions failed", slog.Any("error", err))
      } else {
          suggestions = append(suggestions, historicalSuggestions...)
      }
      
      // Rank and filter suggestions
      suggestions = s.rankSuggestions(suggestions, context)
      
      // Deduplicate and limit
      suggestions = s.deduplicateSuggestions(suggestions)
      if len(suggestions) > 10 {
          suggestions = suggestions[:10]
      }
      
      // Cache results
      s.cache.Set(cacheKey, suggestions, 5*time.Minute)
      
      // Store suggestions for feedback tracking
      for _, suggestion := range suggestions {
          s.suggestionStore.Create(ctx, suggestion)
      }
      
      return suggestions, nil
  }
  
  func (s *suggestionServiceImpl) rankSuggestions(
      suggestions []*TaskSuggestion,
      context *WorkContext,
  ) []*TaskSuggestion {
      // Calculate composite score for each suggestion
      for _, suggestion := range suggestions {
          score := 0.0
          
          // Base confidence from source
          score += suggestion.Confidence * 0.3
          
          // Context relevance
          relevance := s.calculateRelevance(suggestion, context)
          suggestion.Relevance = relevance
          score += relevance * 0.3
          
          // Historical feedback score
          feedbackScore := s.getFeedbackScore(suggestion.Source)
          score += feedbackScore * 0.2
          
          // Time-based factors
          timeScore := s.calculateTimeScore(suggestion, context)
          score += timeScore * 0.1
          
          // Priority alignment
          priorityScore := s.calculatePriorityScore(suggestion, context)
          score += priorityScore * 0.1
          
          // Store composite score
          suggestion.Metadata["composite_score"] = score
      }
      
      // Sort by composite score
      sort.Slice(suggestions, func(i, j int) bool {
          scoreI := suggestions[i].Metadata["composite_score"].(float64)
          scoreJ := suggestions[j].Metadata["composite_score"].(float64)
          return scoreI > scoreJ
      })
      
      return suggestions
  }
  
  func (s *suggestionServiceImpl) generateAISuggestions(
      ctx context.Context,
      context *WorkContext,
  ) ([]*TaskSuggestion, error) {
      // Prepare AI prompt with context
      prompt := s.buildAIPrompt(context)
      
      // Call AI service
      response, err := s.aiService.GenerateSuggestions(ctx, prompt)
      if err != nil {
          return nil, err
      }
      
      // Parse AI response into suggestions
      var suggestions []*TaskSuggestion
      for _, aiSugg := range response.Suggestions {
          suggestion := &TaskSuggestion{
              ID:            uuid.New().String(),
              Type:          SuggestionTypeNext,
              Content:       aiSugg.Content,
              Description:   aiSugg.Reasoning,
              Priority:      aiSugg.Priority,
              EstimatedTime: aiSugg.EstimatedDuration,
              Confidence:    aiSugg.Confidence,
              Source: SuggestionSource{
                  Type:       "ai",
                  Name:       response.Model,
                  Confidence: aiSugg.Confidence,
              },
              Keywords:      aiSugg.Keywords,
              Prerequisites: s.identifyPrerequisites(aiSugg, context),
              Metadata:      make(map[string]interface{}),
              GeneratedAt:   time.Now(),
              ExpiresAt:     time.Now().Add(24 * time.Hour),
          }
          
          suggestions = append(suggestions, suggestion)
      }
      
      return suggestions, nil
  }
  ```

- **Configuration Changes:** 
  - Add suggestion service configuration
  - Configure AI model preferences for suggestions
  - Set relevance thresholds and ranking weights

- **Dependencies:**
  - Pattern detection engine from ST-MT-004-001
  - AI service from MT-002
  - Caching library for performance

## 4. Acceptance Criteria
- **Functional Criteria:**
  - Suggestions have >70% relevance based on user feedback
  - Context analysis accurately captures work state
  - Multiple suggestion sources integrated successfully
  - Ranking algorithm produces intuitive results
  - Feedback mechanism improves suggestions over time
  - Suggestions expire appropriately
  - Prerequisites identified correctly
  
- **Technical Criteria:**
  - Suggestion generation completes in <5 seconds
  - Caching reduces redundant calculations by >70%
  - AI integration handles failures gracefully
  - Memory usage remains reasonable with caching
  
- **Integration Criteria:**
  - Works with pattern detection engine
  - Integrates with existing AI service
  - Connects to task storage and history
  
- **Test Criteria:**
  - Relevance scoring validated
  - Ranking algorithm tested
  - Context analysis accuracy verified
  - Feedback loop functionality confirmed

## 5. Testing Requirements
- **Unit Tests:**
  - Context analysis logic
  - Suggestion ranking algorithm
  - Relevance scoring calculations
  - Feedback processing
  - Cache hit/miss scenarios
  - Deduplication logic
  
- **Integration Tests:**
  - Full suggestion generation flow
  - Multi-source suggestion aggregation
  - AI service integration
  - Pattern-based suggestions
  - Historical data analysis
  
- **Manual Testing:**
  - Verify suggestion quality
  - Test feedback mechanism
  - Check suggestion relevance
  - Validate timing of suggestions
  
- **Test Data:**
  - Mock work contexts with various states
  - Historical task data for testing
  - Feedback data samples
  - AI response mocks

## 6. Definition of Done
- **Code Complete:** Suggestion service with all sources integrated
- **Tests Passing:** All unit and integration tests passing (≥85% coverage)
- **Documentation Updated:** API documentation and usage examples
- **Integration Verified:** Works with pattern detection and AI services
- **Review Approved:** Code review including algorithm review

## 7. Dependencies and Blockers
- **Required Sub-Tasks:** ST-MT-004-001 (Pattern Detection Engine)
- **External Dependencies:** AI service from MT-002, caching library
- **Environmental Requirements:** Access to AI services
- **Potential Blockers:** AI service availability and response quality

## 8. Integration Notes
- **Component Interfaces:** Used by CLI suggest command and REPL mode
- **Data Flow:** Context → Analysis → Multi-source Generation → Ranking → Output
- **Error Handling:** Graceful degradation when sources fail
- **Configuration Impact:** New suggestion settings and thresholds