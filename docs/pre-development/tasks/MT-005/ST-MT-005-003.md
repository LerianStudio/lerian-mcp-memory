# ST-MT-005-003: Implement Automated CLI Distribution and Package Management

## 1. Sub-Task Overview
- **Sub-Task ID:** ST-MT-005-003
- **Sub-Task Name:** Implement Automated CLI Distribution and Package Management
- **Parent Task:** MT-005: Production-Ready System with Advanced Features
- **Estimated Duration:** 3 hours
- **Implementation Type:** Code/Infrastructure

## 2. Deliverable Specification
- **Primary Output:** Automated distribution system with Homebrew formula, shell completion, and self-update mechanism
- **Code Location:** 
  - `scripts/homebrew/lmmc.rb` - Homebrew formula
  - `cli/internal/commands/completion.go` - Shell completion command
  - `cli/internal/commands/update.go` - Self-update command
  - `cli/internal/adapters/secondary/updater/release_checker.go` - Update checker
  - `.github/workflows/release.yml` - Release automation
- **Technical Requirements:** Package managers, shell completion, version management, release automation
- **Interface Definition:** Distribution APIs, completion scripts, update mechanisms

## 3. Implementation Details
- **Step-by-Step Approach:**
  1. Create Homebrew formula for CLI distribution
  2. Implement shell completion for bash, zsh, fish
  3. Add version checking and update notification
  4. Create self-update mechanism with verification
  5. Setup automated release workflows
  6. Add installation verification scripts
  7. Implement rollback functionality
  8. Create distribution health checks
  9. Add telemetry for update success rates
  10. Setup package signing and verification

- **Code Examples:**
  ```ruby
  # Homebrew formula
  class Lmmc < Formula
    desc "AI-powered task management and project development CLI"
    homepage "https://github.com/lerianstudio/lerian-mcp-memory"
    version "1.0.0"
    
    if OS.mac?
      if Hardware::CPU.arm?
        url "https://github.com/lerianstudio/lerian-mcp-memory/releases/download/v1.0.0/lmmc-darwin-arm64.tar.gz"
        sha256 "YOUR_ARM64_SHA256"
      else
        url "https://github.com/lerianstudio/lerian-mcp-memory/releases/download/v1.0.0/lmmc-darwin-amd64.tar.gz"
        sha256 "YOUR_AMD64_SHA256"
      end
    end
    
    if OS.linux?
      if Hardware::CPU.arm?
        url "https://github.com/lerianstudio/lerian-mcp-memory/releases/download/v1.0.0/lmmc-linux-arm64.tar.gz"
        sha256 "YOUR_LINUX_ARM64_SHA256"
      else
        url "https://github.com/lerianstudio/lerian-mcp-memory/releases/download/v1.0.0/lmmc-linux-amd64.tar.gz"
        sha256 "YOUR_LINUX_AMD64_SHA256"
      end
    end
    
    def install
      bin.install "lmmc"
      
      # Install shell completions
      generate_completions_from_executable(bin/"lmmc", "completion")
      
      # Install man pages
      man1.install Dir["man/*.1"]
      
      # Install configuration template
      etc.install "config/lmmc.yaml.example" => "lmmc/config.yaml"
    end
    
    def post_install
      # Auto-install shell completion
      system bin/"lmmc", "completion", "install"
      
      # Create user config directory
      (var/"lmmc").mkpath
      
      puts <<~EOS
        üéâ LMMC installed successfully!
        
        To get started:
          1. Run: lmmc init
          2. Configure: lmmc config setup
          3. Create your first task: lmmc task create "Setup project"
        
        Shell completion has been installed automatically.
        Restart your shell or run: source ~/.bashrc (or ~/.zshrc)
        
        For help: lmmc --help
      EOS
    end
    
    test do
      assert_match version.to_s, shell_output("#{bin}/lmmc version")
      assert_match "LMMC CLI", shell_output("#{bin}/lmmc --help")
    end
  end
  ```

  ```go
  // Shell completion command
  package commands

  import (
      "fmt"
      "os"
      "path/filepath"
      
      "github.com/spf13/cobra"
  )

  func NewCompletionCommand() *cobra.Command {
      cmd := &cobra.Command{
          Use:   "completion [bash|zsh|fish|powershell]",
          Short: "Generate shell completion scripts",
          Long: `Generate shell completion scripts for bash, zsh, fish, or powershell.

The completion script will be written to stdout. You can source it or save it to a file
and source it from your shell's configuration file.

Examples:
  # Bash completion
  lmmc completion bash > /usr/local/etc/bash_completion.d/lmmc
  
  # Zsh completion (add to ~/.zshrc)
  lmmc completion zsh > "${fpath[1]}/_lmmc"
  
  # Fish completion
  lmmc completion fish > ~/.config/fish/completions/lmmc.fish
  
  # PowerShell completion (add to profile)
  lmmc completion powershell > lmmc.ps1`,
          DisableFlagsInUseLine: true,
          ValidArgs:             []string{"bash", "zsh", "fish", "powershell"},
          Args:                  cobra.MatchAll(cobra.ExactArgs(1), cobra.OnlyValidArgs),
          RunE: func(cmd *cobra.Command, args []string) error {
              switch args[0] {
              case "bash":
                  return cmd.Root().GenBashCompletion(os.Stdout)
              case "zsh":
                  return cmd.Root().GenZshCompletion(os.Stdout)
              case "fish":
                  return cmd.Root().GenFishCompletion(os.Stdout, true)
              case "powershell":
                  return cmd.Root().GenPowerShellCompletion(os.Stdout)
              }
              return nil
          },
      }

      // Add install subcommand
      installCmd := &cobra.Command{
          Use:   "install",
          Short: "Install shell completion automatically",
          RunE: func(cmd *cobra.Command, args []string) error {
              return installCompletion()
          },
      }
      
      cmd.AddCommand(installCmd)
      return cmd
  }

  func installCompletion() error {
      shell := os.Getenv("SHELL")
      homeDir, err := os.UserHomeDir()
      if err != nil {
          return err
      }

      switch filepath.Base(shell) {
      case "bash":
          return installBashCompletion(homeDir)
      case "zsh":
          return installZshCompletion(homeDir)
      case "fish":
          return installFishCompletion(homeDir)
      default:
          fmt.Printf("Auto-installation not supported for %s. Use manual installation:\n", shell)
          fmt.Printf("  lmmc completion %s\n", filepath.Base(shell))
          return nil
      }
  }

  func installBashCompletion(homeDir string) error {
      completionDir := "/usr/local/etc/bash_completion.d"
      if _, err := os.Stat(completionDir); os.IsNotExist(err) {
          completionDir = filepath.Join(homeDir, ".local/share/bash-completion/completions")
          os.MkdirAll(completionDir, 0755)
      }

      completionFile := filepath.Join(completionDir, "lmmc")
      file, err := os.Create(completionFile)
      if err != nil {
          return err
      }
      defer file.Close()

      cmd := &cobra.Command{Use: "lmmc"}
      err = cmd.GenBashCompletion(file)
      if err != nil {
          return err
      }

      fmt.Printf("‚úÖ Bash completion installed to %s\n", completionFile)
      fmt.Println("Restart your shell or run: source ~/.bashrc")
      return nil
  }

  // Self-update command
  type UpdateService interface {
      CheckForUpdates(ctx context.Context) (*UpdateInfo, error)
      DownloadUpdate(ctx context.Context, version string) error
      ApplyUpdate(ctx context.Context, version string) error
      VerifyInstallation(ctx context.Context) error
  }

  type UpdateInfo struct {
      CurrentVersion string    `json:"current_version"`
      LatestVersion  string    `json:"latest_version"`
      HasUpdate      bool      `json:"has_update"`
      ReleaseNotes   string    `json:"release_notes"`
      DownloadURL    string    `json:"download_url"`
      Signature      string    `json:"signature"`
      PublishedAt    time.Time `json:"published_at"`
  }

  func NewUpdateCommand(deps CommandDeps) *cobra.Command {
      cmd := &cobra.Command{
          Use:   "update",
          Short: "Update LMMC to the latest version",
          Long:  "Check for and install updates to the LMMC CLI",
          RunE: func(cmd *cobra.Command, args []string) error {
              ctx := cmd.Context()
              
              // Check for updates
              fmt.Println("üîç Checking for updates...")
              updateInfo, err := deps.UpdateService.CheckForUpdates(ctx)
              if err != nil {
                  return fmt.Errorf("failed to check for updates: %w", err)
              }

              if !updateInfo.HasUpdate {
                  fmt.Printf("‚úÖ You're already running the latest version (%s)\n", 
                      updateInfo.CurrentVersion)
                  return nil
              }

              fmt.Printf("üÜï Update available: %s ‚Üí %s\n", 
                  updateInfo.CurrentVersion, updateInfo.LatestVersion)
              
              if updateInfo.ReleaseNotes != "" {
                  fmt.Println("\nüìù Release Notes:")
                  fmt.Println(updateInfo.ReleaseNotes)
              }

              // Confirm update
              autoUpdate, _ := cmd.Flags().GetBool("auto")
              if !autoUpdate {
                  fmt.Print("\nDo you want to update? [y/N]: ")
                  var response string
                  fmt.Scanln(&response)
                  if response != "y" && response != "Y" && response != "yes" {
                      fmt.Println("Update cancelled")
                      return nil
                  }
              }

              // Download update
              fmt.Printf("‚¨áÔ∏è  Downloading version %s...\n", updateInfo.LatestVersion)
              err = deps.UpdateService.DownloadUpdate(ctx, updateInfo.LatestVersion)
              if err != nil {
                  return fmt.Errorf("failed to download update: %w", err)
              }

              // Apply update
              fmt.Println("üîÑ Installing update...")
              err = deps.UpdateService.ApplyUpdate(ctx, updateInfo.LatestVersion)
              if err != nil {
                  return fmt.Errorf("failed to apply update: %w", err)
              }

              // Verify installation
              fmt.Println("‚úÖ Verifying installation...")
              err = deps.UpdateService.VerifyInstallation(ctx)
              if err != nil {
                  return fmt.Errorf("installation verification failed: %w", err)
              }

              fmt.Printf("üéâ Successfully updated to version %s!\n", 
                  updateInfo.LatestVersion)
              return nil
          },
      }

      cmd.Flags().BoolP("auto", "a", false, "Auto-update without confirmation")
      cmd.Flags().BoolP("check", "c", false, "Only check for updates, don't install")
      
      return cmd
  }

  // Update service implementation
  type updateServiceImpl struct {
      currentVersion string
      githubRepo     string
      httpClient     *http.Client
      logger         *slog.Logger
  }

  func (u *updateServiceImpl) CheckForUpdates(ctx context.Context) (*UpdateInfo, error) {
      // Get latest release from GitHub API
      url := fmt.Sprintf("https://api.github.com/repos/%s/releases/latest", u.githubRepo)
      
      req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
      if err != nil {
          return nil, err
      }

      resp, err := u.httpClient.Do(req)
      if err != nil {
          return nil, err
      }
      defer resp.Body.Close()

      if resp.StatusCode != http.StatusOK {
          return nil, fmt.Errorf("GitHub API returned %d", resp.StatusCode)
      }

      var release GitHubRelease
      err = json.NewDecoder(resp.Body).Decode(&release)
      if err != nil {
          return nil, err
      }

      latestVersion := strings.TrimPrefix(release.TagName, "v")
      hasUpdate := u.compareVersions(u.currentVersion, latestVersion) < 0

      // Find appropriate asset for current platform
      downloadURL := u.findAssetURL(release.Assets)

      updateInfo := &UpdateInfo{
          CurrentVersion: u.currentVersion,
          LatestVersion:  latestVersion,
          HasUpdate:      hasUpdate,
          ReleaseNotes:   release.Body,
          DownloadURL:    downloadURL,
          PublishedAt:    release.PublishedAt,
      }

      return updateInfo, nil
  }

  func (u *updateServiceImpl) DownloadUpdate(ctx context.Context, version string) error {
      updateInfo, err := u.CheckForUpdates(ctx)
      if err != nil {
          return err
      }

      // Create temp directory
      tempDir, err := os.MkdirTemp("", "lmmc-update-*")
      if err != nil {
          return err
      }
      defer os.RemoveAll(tempDir)

      // Download archive
      resp, err := http.Get(updateInfo.DownloadURL)
      if err != nil {
          return err
      }
      defer resp.Body.Close()

      // Save to temp file
      archivePath := filepath.Join(tempDir, "lmmc.tar.gz")
      file, err := os.Create(archivePath)
      if err != nil {
          return err
      }

      _, err = io.Copy(file, resp.Body)
      file.Close()
      if err != nil {
          return err
      }

      // Extract archive
      err = u.extractArchive(archivePath, tempDir)
      if err != nil {
          return err
      }

      // Store extracted binary path for apply step
      u.tempBinaryPath = filepath.Join(tempDir, "lmmc")
      return nil
  }

  func (u *updateServiceImpl) ApplyUpdate(ctx context.Context, version string) error {
      // Get current executable path
      currentExe, err := os.Executable()
      if err != nil {
          return err
      }

      // Create backup
      backupPath := currentExe + ".backup"
      err = u.copyFile(currentExe, backupPath)
      if err != nil {
          return err
      }

      // Replace current executable
      err = u.copyFile(u.tempBinaryPath, currentExe)
      if err != nil {
          // Restore backup
          os.Rename(backupPath, currentExe)
          return err
      }

      // Set executable permissions
      err = os.Chmod(currentExe, 0755)
      if err != nil {
          return err
      }

      // Clean up backup after successful update
      os.Remove(backupPath)
      return nil
  }
  ```

  ```yaml
  # GitHub Actions release workflow
  name: Release

  on:
    push:
      tags:
        - 'v*'

  jobs:
    build:
      runs-on: ubuntu-latest
      strategy:
        matrix:
          include:
            - os: linux
              arch: amd64
            - os: linux
              arch: arm64
            - os: darwin
              arch: amd64
            - os: darwin
              arch: arm64
            - os: windows
              arch: amd64

      steps:
        - uses: actions/checkout@v4

        - uses: actions/setup-go@v4
          with:
            go-version: '1.21'

        - name: Build binary
          env:
            GOOS: ${{ matrix.os }}
            GOARCH: ${{ matrix.arch }}
          run: |
            go build -ldflags="-X main.version=${{ github.ref_name }}" \
              -o lmmc-${{ matrix.os }}-${{ matrix.arch }} \
              ./cmd/cli

        - name: Create archive
          run: |
            if [ "${{ matrix.os }}" = "windows" ]; then
              zip lmmc-${{ matrix.os }}-${{ matrix.arch }}.zip lmmc-${{ matrix.os }}-${{ matrix.arch }}.exe
            else
              tar -czf lmmc-${{ matrix.os }}-${{ matrix.arch }}.tar.gz lmmc-${{ matrix.os }}-${{ matrix.arch }}
            fi

        - name: Upload artifacts
          uses: actions/upload-artifact@v4
          with:
            name: lmmc-${{ matrix.os }}-${{ matrix.arch }}
            path: lmmc-${{ matrix.os }}-${{ matrix.arch }}.*

    release:
      needs: build
      runs-on: ubuntu-latest
      steps:
        - uses: actions/checkout@v4

        - name: Download artifacts
          uses: actions/download-artifact@v4

        - name: Create release
          uses: softprops/action-gh-release@v1
          with:
            files: |
              lmmc-*/lmmc-*
            generate_release_notes: true
            draft: false
            prerelease: false
          env:
            GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

        - name: Update Homebrew formula
          uses: mislav/bump-homebrew-formula-action@v3
          with:
            formula-name: lmmc
            homebrew-tap: lerianstudio/homebrew-tap
            base-branch: main
            create-pullrequest: true
          env:
            COMMITTER_TOKEN: ${{ secrets.HOMEBREW_TAP_TOKEN }}
  ```

- **Configuration Changes:** 
  - Add update check intervals
  - Configure package distribution settings
  - Set release automation parameters

- **Dependencies:**
  - GitHub API for release information
  - Package manager integrations (Homebrew)
  - Shell completion frameworks

## 4. Acceptance Criteria
- **Functional Criteria:**
  - Homebrew formula installs CLI correctly
  - Shell completion works for all supported shells
  - Self-update mechanism functions properly
  - Version checking and notifications work
  - Release automation creates proper packages
  - Installation verification passes
  - Rollback functionality works if needed
  
- **Technical Criteria:**
  - Package installation completes in <30 seconds
  - Update downloads and installs reliably
  - Shell completion loads without errors
  - Release artifacts are properly signed
  
- **Integration Criteria:**
  - Works with existing CLI commands
  - Compatible with all supported platforms
  - Integrates with CI/CD pipeline
  
- **Test Criteria:**
  - Installation tested on multiple platforms
  - Update process thoroughly validated
  - Shell completion tested in all environments
  - Package integrity verified

## 5. Testing Requirements
- **Unit Tests:**
  - Version comparison logic
  - Update download and verification
  - Shell completion generation
  - Package integrity checks
  - Error handling scenarios
  
- **Integration Tests:**
  - Full installation flow
  - Update process end-to-end
  - Shell completion integration
  - Release automation workflow
  
- **Manual Testing:**
  - Install via Homebrew
  - Test shell completion
  - Verify update process
  - Check cross-platform compatibility
  
- **Test Data:**
  - Mock release information
  - Test packages for verification
  - Shell environment samples
  - Update scenarios

## 6. Definition of Done
- **Code Complete:** Distribution and update system fully implemented
- **Tests Passing:** All installation and update tests passing (‚â•80% coverage)
- **Documentation Updated:** Installation and update documentation complete
- **Integration Verified:** Works across all supported platforms
- **Review Approved:** Security review of update mechanism completed

## 7. Dependencies and Blockers
- **Required Sub-Tasks:** None (can run in parallel with other MT-005 tasks)
- **External Dependencies:** GitHub repository, Homebrew tap repository
- **Environmental Requirements:** Multi-platform build environment
- **Potential Blockers:** Package manager approval processes

## 8. Integration Notes
- **Component Interfaces:** Used by CLI update and completion commands
- **Data Flow:** Release Server ‚Üí Download ‚Üí Verification ‚Üí Installation
- **Error Handling:** Robust error handling with rollback capability
- **Configuration Impact:** New update and distribution settings