# ST-MT-005-004: Advanced Search and Filtering System

## 1. Sub-Task Overview
- **Sub-Task ID:** ST-MT-005-004
- **Sub-Task Name:** Advanced Search and Filtering System
- **Parent Task:** MT-005: Production-Ready System with Advanced Features
- **Estimated Duration:** 3 hours
- **Implementation Type:** Code

## 2. Deliverable Specification
- **Primary Output:** Comprehensive search and filtering system with fuzzy search, advanced queries, and intelligent suggestions
- **Code Location:** 
  - `cli/internal/domain/services/search_service.go` - Main search service
  - `cli/internal/adapters/secondary/search/indexer.go` - Search indexing
  - `cli/internal/adapters/secondary/search/query_parser.go` - Query parsing
  - `cli/internal/adapters/primary/commands/search.go` - Search CLI commands
  - `cli/internal/adapters/secondary/search/filters.go` - Advanced filters
- **Technical Requirements:** Full-text search, fuzzy matching, query DSL, search indexing, filtering
- **Interface Definition:** SearchService interface, query syntax, filter definitions

## 3. Implementation Details
- **Step-by-Step Approach:**
  1. Create search index and full-text search engine
  2. Implement fuzzy search with ranking algorithms
  3. Add advanced query DSL parser
  4. Create intelligent search suggestions
  5. Implement complex filtering system
  6. Add search result ranking and scoring
  7. Create search history and favorites
  8. Implement saved searches and alerts
  9. Add search analytics and optimization
  10. Create search export and sharing

- **Code Examples:**
  ```go
  // Search service interface
  package services

  type SearchService interface {
      // Basic search
      Search(ctx context.Context, query SearchQuery) (*SearchResults, error)
      SearchTasks(ctx context.Context, repository string, query string) ([]*entities.Task, error)
      SearchProjects(ctx context.Context, query string) ([]*entities.Project, error)
      
      // Advanced search
      AdvancedSearch(ctx context.Context, criteria SearchCriteria) (*SearchResults, error)
      FuzzySearch(ctx context.Context, query string, threshold float64) (*SearchResults, error)
      
      // Search management
      SaveSearch(ctx context.Context, search *SavedSearch) error
      GetSavedSearches(ctx context.Context, userID string) ([]*SavedSearch, error)
      GetSearchSuggestions(ctx context.Context, partial string) ([]string, error)
      
      // Search analytics
      RecordSearch(ctx context.Context, query string, resultCount int) error
      GetSearchAnalytics(ctx context.Context, period TimePeriod) (*SearchAnalytics, error)
      
      // Index management
      ReindexRepository(ctx context.Context, repository string) error
      GetIndexStatus(ctx context.Context) (*IndexStatus, error)
  }

  type SearchQuery struct {
      Text         string                 `json:"text"`
      Repository   string                 `json:"repository,omitempty"`
      Filters      map[string]interface{} `json:"filters,omitempty"`
      SortBy       string                 `json:"sort_by,omitempty"`
      SortOrder    string                 `json:"sort_order,omitempty"`
      Limit        int                    `json:"limit,omitempty"`
      Offset       int                    `json:"offset,omitempty"`
      Fuzzy        bool                   `json:"fuzzy,omitempty"`
      FuzzyLevel   int                    `json:"fuzzy_level,omitempty"`
  }

  type SearchCriteria struct {
      // Text criteria
      Title           StringCriteria     `json:"title,omitempty"`
      Content         StringCriteria     `json:"content,omitempty"`
      Tags            []string           `json:"tags,omitempty"`
      
      // Task criteria
      Status          []string           `json:"status,omitempty"`
      Priority        []string           `json:"priority,omitempty"`
      Assignee        []string           `json:"assignee,omitempty"`
      
      // Time criteria
      CreatedAfter    *time.Time         `json:"created_after,omitempty"`
      CreatedBefore   *time.Time         `json:"created_before,omitempty"`
      UpdatedAfter    *time.Time         `json:"updated_after,omitempty"`
      UpdatedBefore   *time.Time         `json:"updated_before,omitempty"`
      
      // Metadata criteria
      HasMetadata     map[string]bool    `json:"has_metadata,omitempty"`
      MetadataEquals  map[string]string  `json:"metadata_equals,omitempty"`
      
      // Relationship criteria
      HasDependencies bool               `json:"has_dependencies,omitempty"`
      DependsOn       []string           `json:"depends_on,omitempty"`
      
      // Pattern criteria
      MatchesPattern  []string           `json:"matches_pattern,omitempty"`
      
      // Logical operators
      AND             []*SearchCriteria  `json:"and,omitempty"`
      OR              []*SearchCriteria  `json:"or,omitempty"`
      NOT             *SearchCriteria    `json:"not,omitempty"`
  }

  type StringCriteria struct {
      Exact      string   `json:"exact,omitempty"`
      Contains   string   `json:"contains,omitempty"`
      StartsWith string   `json:"starts_with,omitempty"`
      EndsWith   string   `json:"ends_with,omitempty"`
      Regex      string   `json:"regex,omitempty"`
      Fuzzy      string   `json:"fuzzy,omitempty"`
      OneOf      []string `json:"one_of,omitempty"`
  }

  type SearchResults struct {
      Query        SearchQuery      `json:"query"`
      TotalCount   int              `json:"total_count"`
      ResultCount  int              `json:"result_count"`
      Results      []SearchResult   `json:"results"`
      Facets       map[string]Facet `json:"facets,omitempty"`
      Suggestions  []string         `json:"suggestions,omitempty"`
      SearchTime   time.Duration    `json:"search_time"`
      HasMore      bool             `json:"has_more"`
  }

  type SearchResult struct {
      Type        string                 `json:"type"`        // task, project, pattern, etc.
      ID          string                 `json:"id"`
      Title       string                 `json:"title"`
      Content     string                 `json:"content,omitempty"`
      Score       float64                `json:"score"`       // Relevance score 0-1
      Highlights  map[string][]string    `json:"highlights"`  // Highlighted snippets
      Metadata    map[string]interface{} `json:"metadata"`
      Repository  string                 `json:"repository"`
      CreatedAt   time.Time              `json:"created_at"`
      UpdatedAt   time.Time              `json:"updated_at"`
  }

  type SavedSearch struct {
      ID           string        `json:"id"`
      Name         string        `json:"name"`
      Description  string        `json:"description,omitempty"`
      Query        SearchQuery   `json:"query"`
      UserID       string        `json:"user_id"`
      IsAlert      bool          `json:"is_alert"`
      AlertConfig  *AlertConfig  `json:"alert_config,omitempty"`
      CreatedAt    time.Time     `json:"created_at"`
      LastRun      *time.Time    `json:"last_run,omitempty"`
      RunCount     int           `json:"run_count"`
  }

  // Search service implementation
  type searchServiceImpl struct {
      indexer         Indexer
      queryParser     QueryParser
      taskStore       storage.TaskStorage
      projectStore    storage.ProjectStorage
      patternStore    storage.PatternStorage
      searchStore     storage.SearchStorage
      cache           cache.Cache
      logger          *slog.Logger
  }

  func (s *searchServiceImpl) Search(ctx context.Context, query SearchQuery) (*SearchResults, error) {
      start := time.Now()
      
      // Parse and validate query
      parsedQuery, err := s.queryParser.Parse(query.Text)
      if err != nil {
          return nil, fmt.Errorf("invalid query: %w", err)
      }
      
      // Apply filters
      filters := s.buildFilters(query.Filters)
      
      // Execute search against index
      indexResults, err := s.indexer.Search(ctx, SearchRequest{
          Query:      parsedQuery,
          Repository: query.Repository,
          Filters:    filters,
          SortBy:     query.SortBy,
          SortOrder:  query.SortOrder,
          Limit:      query.Limit,
          Offset:     query.Offset,
          Fuzzy:      query.Fuzzy,
          FuzzyLevel: query.FuzzyLevel,
      })
      if err != nil {
          return nil, err
      }
      
      // Enhance results with additional data
      results := make([]SearchResult, len(indexResults.Hits))
      for i, hit := range indexResults.Hits {
          result := SearchResult{
              Type:       hit.Type,
              ID:         hit.ID,
              Title:      hit.Title,
              Content:    hit.Content,
              Score:      hit.Score,
              Highlights: hit.Highlights,
              Metadata:   hit.Metadata,
              Repository: hit.Repository,
              CreatedAt:  hit.CreatedAt,
              UpdatedAt:  hit.UpdatedAt,
          }
          
          // Add additional context based on type
          if hit.Type == "task" {
              task, err := s.taskStore.GetByID(ctx, hit.ID)
              if err == nil {
                  result.Metadata["status"] = task.Status
                  result.Metadata["priority"] = task.Priority
              }
          }
          
          results[i] = result
      }
      
      // Generate suggestions for better queries
      suggestions := s.generateSuggestions(query.Text, indexResults.TotalCount)
      
      // Record search for analytics
      s.RecordSearch(ctx, query.Text, len(results))
      
      searchResults := &SearchResults{
          Query:       query,
          TotalCount:  indexResults.TotalCount,
          ResultCount: len(results),
          Results:     results,
          Facets:      s.buildFacets(indexResults.Facets),
          Suggestions: suggestions,
          SearchTime:  time.Since(start),
          HasMore:     indexResults.HasMore,
      }
      
      return searchResults, nil
  }

  func (s *searchServiceImpl) AdvancedSearch(ctx context.Context, criteria SearchCriteria) (*SearchResults, error) {
      // Convert criteria to internal query format
      query := s.buildQueryFromCriteria(criteria)
      
      // Execute search
      return s.indexer.AdvancedSearch(ctx, query)
  }

  func (s *searchServiceImpl) FuzzySearch(ctx context.Context, query string, threshold float64) (*SearchResults, error) {
      // Implement fuzzy search with Levenshtein distance
      results := make([]SearchResult, 0)
      
      // Search across different entity types
      tasks, err := s.taskStore.GetAll(ctx)
      if err != nil {
          return nil, err
      }
      
      for _, task := range tasks {
          // Calculate fuzzy match scores
          titleScore := s.calculateFuzzyScore(query, task.Title)
          contentScore := s.calculateFuzzyScore(query, task.Content)
          
          maxScore := math.Max(titleScore, contentScore)
          if maxScore >= threshold {
              result := SearchResult{
                  Type:       "task",
                  ID:         task.ID,
                  Title:      task.Title,
                  Content:    task.Content,
                  Score:      maxScore,
                  Repository: task.Repository,
                  CreatedAt:  task.CreatedAt,
                  UpdatedAt:  task.UpdatedAt,
                  Metadata: map[string]interface{}{
                      "status":   task.Status,
                      "priority": task.Priority,
                  },
              }
              results = append(results, result)
          }
      }
      
      // Sort by score descending
      sort.Slice(results, func(i, j int) bool {
          return results[i].Score > results[j].Score
      })
      
      return &SearchResults{
          TotalCount:  len(results),
          ResultCount: len(results),
          Results:     results,
          SearchTime:  time.Since(time.Now()),
      }, nil
  }

  // Query parser for advanced search syntax
  type QueryParser interface {
      Parse(query string) (*ParsedQuery, error)
      Validate(query string) error
      GetSyntaxHelp() string
  }

  type ParsedQuery struct {
      Terms      []QueryTerm   `json:"terms"`
      Filters    []QueryFilter `json:"filters"`
      Sort       *SortSpec     `json:"sort,omitempty"`
      Operators  []Operator    `json:"operators"`
  }

  type QueryTerm struct {
      Text     string  `json:"text"`
      Field    string  `json:"field,omitempty"`
      Weight   float64 `json:"weight"`
      Required bool    `json:"required"`
      Excluded bool    `json:"excluded"`
  }

  type queryParserImpl struct {
      syntax map[string]SyntaxRule
  }

  func (p *queryParserImpl) Parse(query string) (*ParsedQuery, error) {
      // Implement query parsing for syntax like:
      // title:"setup project" AND status:in_progress OR priority:high
      // content:authentication -status:completed
      // created:>2024-01-01 updated:<2024-02-01
      // tag:bug OR tag:feature
      // depends_on:exists
      
      lexer := NewQueryLexer(query)
      tokens, err := lexer.Tokenize()
      if err != nil {
          return nil, err
      }
      
      parser := NewQueryGrammarParser(tokens)
      parsed, err := parser.Parse()
      if err != nil {
          return nil, err
      }
      
      return parsed, nil
  }

  // Search CLI command
  func NewSearchCommand(deps CommandDeps) *cobra.Command {
      cmd := &cobra.Command{
          Use:   "search [query]",
          Short: "Search tasks, projects, and patterns",
          Long: `Advanced search across all your tasks, projects, and patterns.

Syntax:
  Basic search:
    lmmc search "authentication setup"
    
  Field-specific search:
    lmmc search 'title:"user management" AND status:in_progress'
    
  Advanced filters:
    lmmc search 'priority:high OR priority:urgent'
    lmmc search 'created:>2024-01-01 AND status:completed'
    lmmc search 'tag:bug -tag:wontfix'
    
  Fuzzy search:
    lmmc search --fuzzy "athentication"  # matches "authentication"
    
  Saved searches:
    lmmc search --saved "weekly-review"
    lmmc search --save "high-priority-bugs" 'priority:high AND tag:bug'`,
          RunE: func(cmd *cobra.Command, args []string) error {
              ctx := cmd.Context()
              
              // Get search parameters
              fuzzy, _ := cmd.Flags().GetBool("fuzzy")
              fuzzyLevel, _ := cmd.Flags().GetInt("fuzzy-level")
              savedName, _ := cmd.Flags().GetString("saved")
              saveName, _ := cmd.Flags().GetString("save")
              limit, _ := cmd.Flags().GetInt("limit")
              repository, _ := cmd.Flags().GetString("repository")
              format, _ := cmd.Flags().GetString("output")
              
              var query string
              if len(args) > 0 {
                  query = strings.Join(args, " ")
              } else if savedName != "" {
                  // Load saved search
                  savedSearch, err := deps.SearchService.GetSavedSearch(ctx, savedName)
                  if err != nil {
                      return err
                  }
                  query = savedSearch.Query.Text
              } else {
                  return fmt.Errorf("search query is required")
              }
              
              // Build search query
              searchQuery := SearchQuery{
                  Text:       query,
                  Repository: repository,
                  Fuzzy:      fuzzy,
                  FuzzyLevel: fuzzyLevel,
                  Limit:      limit,
              }
              
              // Execute search
              results, err := deps.SearchService.Search(ctx, searchQuery)
              if err != nil {
                  return err
              }
              
              // Save search if requested
              if saveName != "" {
                  savedSearch := &SavedSearch{
                      ID:          uuid.New().String(),
                      Name:        saveName,
                      Query:       searchQuery,
                      UserID:      deps.Config.GetUserID(),
                      CreatedAt:   time.Now(),
                  }
                  err := deps.SearchService.SaveSearch(ctx, savedSearch)
                  if err != nil {
                      fmt.Printf("Warning: Could not save search: %v\n", err)
                  } else {
                      fmt.Printf("Search saved as '%s'\n", saveName)
                  }
              }
              
              // Display results
              switch format {
              case "json":
                  return displaySearchResultsJSON(results)
              case "table":
                  return displaySearchResultsTable(results)
              default:
                  return displaySearchResultsDefault(results)
              }
          },
      }
      
      cmd.Flags().BoolP("fuzzy", "f", false, "Enable fuzzy search")
      cmd.Flags().IntP("fuzzy-level", "l", 2, "Fuzzy search edit distance (1-3)")
      cmd.Flags().StringP("saved", "s", "", "Use saved search")
      cmd.Flags().String("save", "", "Save search with name")
      cmd.Flags().IntP("limit", "n", 20, "Limit number of results")
      cmd.Flags().StringP("repository", "r", "", "Search within specific repository")
      cmd.Flags().StringP("output", "o", "default", "Output format (default, table, json)")
      cmd.Flags().BoolP("interactive", "i", false, "Interactive search mode")
      
      return cmd
  }

  func displaySearchResultsDefault(results *SearchResults) error {
      if results.ResultCount == 0 {
          fmt.Println("No results found")
          if len(results.Suggestions) > 0 {
              fmt.Println("\nDid you mean:")
              for _, suggestion := range results.Suggestions {
                  fmt.Printf("  %s\n", suggestion)
              }
          }
          return nil
      }
      
      fmt.Printf("Found %d results (%.2fms)\n\n", 
          results.TotalCount, float64(results.SearchTime.Nanoseconds())/1e6)
      
      for i, result := range results.Results {
          // Result header
          fmt.Printf("%d. %s [%s] (%.2f)\n", 
              i+1, result.Title, result.Type, result.Score)
          
          // Highlighted content snippet
          if content := result.Content; content != "" {
              if len(content) > 100 {
                  content = content[:100] + "..."
              }
              fmt.Printf("   %s\n", content)
          }
          
          // Metadata
          if status, ok := result.Metadata["status"]; ok {
              fmt.Printf("   Status: %s", status)
          }
          if priority, ok := result.Metadata["priority"]; ok {
              fmt.Printf("  Priority: %s", priority)
          }
          fmt.Printf("  Repository: %s\n", result.Repository)
          
          // Highlights
          if len(result.Highlights) > 0 {
              fmt.Printf("   Matches: ")
              for field, highlights := range result.Highlights {
                  for _, highlight := range highlights {
                      fmt.Printf("[%s: %s] ", field, highlight)
                  }
              }
              fmt.Println()
          }
          
          fmt.Println()
      }
      
      if results.HasMore {
          fmt.Printf("... and %d more results\n", 
              results.TotalCount-results.ResultCount)
      }
      
      return nil
  }
  ```

- **Configuration Changes:** 
  - Add search index configuration
  - Configure fuzzy search parameters
  - Set query timeout and limits
  - Add search analytics settings

- **Dependencies:**
  - Full-text search engine (Bleve or similar)
  - Query parsing libraries
  - Fuzzy matching algorithms

## 4. Acceptance Criteria
- **Functional Criteria:**
  - Full-text search returns relevant results
  - Fuzzy search finds approximate matches
  - Advanced query syntax works correctly
  - Search suggestions improve query experience
  - Saved searches can be created and reused
  - Search results are properly ranked
  - Filtering system works with all criteria
  
- **Technical Criteria:**
  - Search completes in <2 seconds for most queries
  - Index updates in real-time
  - Memory usage stays reasonable for large datasets
  - Search accuracy >85% for relevant queries
  
- **Integration Criteria:**
  - Works with all existing data types
  - Integrates with CLI command structure
  - Compatible with analytics system
  
- **Test Criteria:**
  - Search accuracy validated with test queries
  - Performance benchmarks met
  - Fuzzy search effectiveness verified
  - Query parsing handles edge cases

## 5. Testing Requirements
- **Unit Tests:**
  - Query parsing logic
  - Fuzzy search algorithms
  - Search ranking calculations
  - Filter application
  - Index operations
  - Search result formatting
  
- **Integration Tests:**
  - Full search workflow
  - Index building and updates
  - Saved search functionality
  - Search analytics tracking
  
- **Manual Testing:**
  - Search relevance validation
  - Query syntax testing
  - Performance with large datasets
  - User experience evaluation
  
- **Test Data:**
  - Large dataset for performance testing
  - Known queries with expected results
  - Edge cases and malformed queries
  - Multi-language content samples

## 6. Definition of Done
- **Code Complete:** Full search and filtering system implemented
- **Tests Passing:** All search tests passing (≥85% coverage)
- **Documentation Updated:** Search syntax and usage guide created
- **Integration Verified:** Works with all data types and commands
- **Review Approved:** Search accuracy and performance validated

## 7. Dependencies and Blockers
- **Required Sub-Tasks:** None (can work with existing data structures)
- **External Dependencies:** Search engine library, query parsing tools
- **Environmental Requirements:** Sufficient memory for search index
- **Potential Blockers:** Search engine licensing or performance issues

## 8. Integration Notes
- **Component Interfaces:** Used by all CLI commands that need search
- **Data Flow:** Data → Index → Query → Results → Display
- **Error Handling:** Graceful handling of malformed queries
- **Configuration Impact:** New search and indexing configuration section