# ST-MT-005-005: Export and Integration Capabilities

## 1. Sub-Task Overview
- **Sub-Task ID:** ST-MT-005-005
- **Sub-Task Name:** Export and Integration Capabilities
- **Parent Task:** MT-005: Production-Ready System with Advanced Features
- **Estimated Duration:** 3 hours
- **Implementation Type:** Code

## 2. Deliverable Specification
- **Primary Output:** Comprehensive export system and third-party integrations with multiple formats and APIs
- **Code Location:** 
  - `cli/internal/adapters/secondary/export/exporters.go` - Export implementations
  - `cli/internal/adapters/secondary/integrations/` - Third-party integrations
  - `cli/internal/adapters/primary/commands/export.go` - Export CLI commands
  - `cli/internal/domain/services/export_service.go` - Export orchestration
  - `cli/internal/adapters/secondary/export/templates.go` - Export templates
- **Technical Requirements:** Multiple export formats, API integrations, template system, scheduling
- **Interface Definition:** ExportService interface, integration APIs, format specifications

## 3. Implementation Details
- **Step-by-Step Approach:**
  1. Create comprehensive export service with multiple formats
  2. Implement third-party integrations (GitHub, Jira, Notion, etc.)
  3. Add export templates and customization
  4. Create scheduled exports and automation
  5. Implement export history and versioning
  6. Add data transformation and filtering
  7. Create webhook and API endpoints
  8. Implement real-time sync capabilities
  9. Add export validation and verification
  10. Create import capabilities for data migration

- **Code Examples:**
  ```go
  // Export service interface
  package services

  type ExportService interface {
      // Basic exports
      ExportTasks(ctx context.Context, request ExportRequest) (*ExportResult, error)
      ExportProjects(ctx context.Context, request ExportRequest) (*ExportResult, error)
      ExportAnalytics(ctx context.Context, request ExportRequest) (*ExportResult, error)
      
      // Batch operations
      ExportRepository(ctx context.Context, repository string, formats []ExportFormat) ([]*ExportResult, error)
      ExportMultiple(ctx context.Context, requests []ExportRequest) ([]*ExportResult, error)
      
      // Templates
      CreateTemplate(ctx context.Context, template *ExportTemplate) error
      GetTemplates(ctx context.Context, category string) ([]*ExportTemplate, error)
      ApplyTemplate(ctx context.Context, templateID string, data interface{}) (*ExportResult, error)
      
      // Scheduled exports
      ScheduleExport(ctx context.Context, schedule *ExportSchedule) error
      GetScheduledExports(ctx context.Context, userID string) ([]*ExportSchedule, error)
      
      // Integration management
      CreateIntegration(ctx context.Context, integration *Integration) error
      TestIntegration(ctx context.Context, integrationID string) error
      SyncWithIntegration(ctx context.Context, integrationID string, data interface{}) error
  }

  type ExportFormat string

  const (
      FormatJSON       ExportFormat = "json"
      FormatCSV        ExportFormat = "csv"
      FormatExcel      ExportFormat = "excel"
      FormatPDF        ExportFormat = "pdf"
      FormatMarkdown   ExportFormat = "markdown"
      FormatHTML       ExportFormat = "html"
      FormatXML        ExportFormat = "xml"
      FormatYAML       ExportFormat = "yaml"
      FormatGantt      ExportFormat = "gantt"
      FormatKanban     ExportFormat = "kanban"
      FormatCalendar   ExportFormat = "calendar"
      FormatMindMap    ExportFormat = "mindmap"
      FormatGitHubMD   ExportFormat = "github-md"
      FormatJiraCSV    ExportFormat = "jira-csv"
      FormatTrelloJSON ExportFormat = "trello-json"
      FormatNotionCSV  ExportFormat = "notion-csv"
  )

  type ExportRequest struct {
      Repository      string                 `json:"repository"`
      Format          ExportFormat           `json:"format"`
      Filters         map[string]interface{} `json:"filters,omitempty"`
      TemplateID      string                 `json:"template_id,omitempty"`
      OutputPath      string                 `json:"output_path,omitempty"`
      Options         ExportOptions          `json:"options"`
      Metadata        map[string]string      `json:"metadata,omitempty"`
  }

  type ExportOptions struct {
      IncludeMetadata     bool     `json:"include_metadata"`
      IncludeRelations    bool     `json:"include_relations"`
      IncludeAnalytics    bool     `json:"include_analytics"`
      CompressOutput      bool     `json:"compress_output"`
      SplitLargeFiles     bool     `json:"split_large_files"`
      MaxFileSize         int64    `json:"max_file_size"`
      CustomFields        []string `json:"custom_fields,omitempty"`
      DateFormat          string   `json:"date_format,omitempty"`
      Timezone            string   `json:"timezone,omitempty"`
      PasswordProtect     bool     `json:"password_protect"`
      WatermarkText       string   `json:"watermark_text,omitempty"`
  }

  type ExportResult struct {
      ID              string            `json:"id"`
      Request         ExportRequest     `json:"request"`
      Status          ExportStatus      `json:"status"`
      OutputPath      string            `json:"output_path"`
      OutputSize      int64             `json:"output_size"`
      RecordCount     int               `json:"record_count"`
      StartedAt       time.Time         `json:"started_at"`
      CompletedAt     *time.Time        `json:"completed_at,omitempty"`
      Duration        time.Duration     `json:"duration"`
      Error           string            `json:"error,omitempty"`
      Checksums       map[string]string `json:"checksums,omitempty"`
      DownloadURL     string            `json:"download_url,omitempty"`
      ExpiresAt       *time.Time        `json:"expires_at,omitempty"`
  }

  type ExportTemplate struct {
      ID              string                 `json:"id"`
      Name            string                 `json:"name"`
      Description     string                 `json:"description"`
      Category        string                 `json:"category"`
      Format          ExportFormat           `json:"format"`
      Fields          []TemplateField        `json:"fields"`
      Transformations []Transformation       `json:"transformations,omitempty"`
      Layout          TemplateLayout         `json:"layout"`
      Styling         TemplateStyle          `json:"styling,omitempty"`
      Variables       map[string]Variable    `json:"variables,omitempty"`
      CreatedBy       string                 `json:"created_by"`
      IsPublic        bool                   `json:"is_public"`
      CreatedAt       time.Time              `json:"created_at"`
      UpdatedAt       time.Time              `json:"updated_at"`
  }

  // Export service implementation
  type exportServiceImpl struct {
      exporters       map[ExportFormat]Exporter
      templateStore   storage.TemplateStorage
      exportStore     storage.ExportStorage
      integrations    map[string]Integration
      scheduler       Scheduler
      fileStorage     storage.FileStorage
      logger          *slog.Logger
  }

  func NewExportService(deps ExportDeps) ExportService {
      service := &exportServiceImpl{
          exporters:     make(map[ExportFormat]Exporter),
          templateStore: deps.TemplateStorage,
          exportStore:   deps.ExportStorage,
          integrations:  make(map[string]Integration),
          scheduler:     deps.Scheduler,
          fileStorage:   deps.FileStorage,
          logger:        deps.Logger,
      }

      // Register exporters
      service.exporters[FormatJSON] = NewJSONExporter()
      service.exporters[FormatCSV] = NewCSVExporter()
      service.exporters[FormatExcel] = NewExcelExporter()
      service.exporters[FormatPDF] = NewPDFExporter()
      service.exporters[FormatMarkdown] = NewMarkdownExporter()
      service.exporters[FormatHTML] = NewHTMLExporter()
      service.exporters[FormatGantt] = NewGanttExporter()
      
      // Register integrations
      service.integrations["github"] = NewGitHubIntegration(deps.GitHubConfig)
      service.integrations["jira"] = NewJiraIntegration(deps.JiraConfig)
      service.integrations["notion"] = NewNotionIntegration(deps.NotionConfig)
      service.integrations["trello"] = NewTrelloIntegration(deps.TrelloConfig)
      
      return service
  }

  func (e *exportServiceImpl) ExportTasks(ctx context.Context, request ExportRequest) (*ExportResult, error) {
      // Create export result record
      result := &ExportResult{
          ID:          uuid.New().String(),
          Request:     request,
          Status:      ExportStatusRunning,
          StartedAt:   time.Now(),
      }
      
      // Store export record
      err := e.exportStore.Create(ctx, result)
      if err != nil {
          return nil, err
      }
      
      // Get exporter for format
      exporter, exists := e.exporters[request.Format]
      if !exists {
          result.Status = ExportStatusFailed
          result.Error = fmt.Sprintf("unsupported format: %s", request.Format)
          e.exportStore.Update(ctx, result)
          return result, fmt.Errorf("unsupported format: %s", request.Format)
      }
      
      // Apply filters to get data
      tasks, err := e.getFilteredTasks(ctx, request)
      if err != nil {
          result.Status = ExportStatusFailed
          result.Error = err.Error()
          e.exportStore.Update(ctx, result)
          return result, err
      }
      
      // Apply template if specified
      var exportData interface{} = tasks
      if request.TemplateID != "" {
          template, err := e.templateStore.GetByID(ctx, request.TemplateID)
          if err != nil {
              result.Status = ExportStatusFailed
              result.Error = err.Error()
              e.exportStore.Update(ctx, result)
              return result, err
          }
          
          exportData, err = e.applyTemplate(template, tasks)
          if err != nil {
              result.Status = ExportStatusFailed
              result.Error = err.Error()
              e.exportStore.Update(ctx, result)
              return result, err
          }
      }
      
      // Export data
      outputPath, err := e.generateOutputPath(request)
      if err != nil {
          result.Status = ExportStatusFailed
          result.Error = err.Error()
          e.exportStore.Update(ctx, result)
          return result, err
      }
      
      exportResult, err := exporter.Export(ctx, ExportData{
          Data:       exportData,
          OutputPath: outputPath,
          Options:    request.Options,
      })
      if err != nil {
          result.Status = ExportStatusFailed
          result.Error = err.Error()
          e.exportStore.Update(ctx, result)
          return result, err
      }
      
      // Update result
      now := time.Now()
      result.CompletedAt = &now
      result.Duration = now.Sub(result.StartedAt)
      result.Status = ExportStatusCompleted
      result.OutputPath = exportResult.OutputPath
      result.OutputSize = exportResult.Size
      result.RecordCount = len(tasks)
      result.Checksums = exportResult.Checksums
      
      // Generate download URL if needed
      if request.Options.PasswordProtect {
          result.DownloadURL, err = e.generateSecureDownloadURL(result.OutputPath)
          if err != nil {
              e.logger.Warn("failed to generate download URL", slog.Any("error", err))
          }
      }
      
      // Set expiration
      if request.Options.CompressOutput {
          expirationTime := time.Now().Add(7 * 24 * time.Hour) // 7 days
          result.ExpiresAt = &expirationTime
      }
      
      err = e.exportStore.Update(ctx, result)
      if err != nil {
          e.logger.Error("failed to update export result", slog.Any("error", err))
      }
      
      return result, nil
  }

  // Specific exporters
  type Exporter interface {
      Export(ctx context.Context, data ExportData) (*ExportOutput, error)
      GetSupportedOptions() []string
      Validate(options ExportOptions) error
  }

  type CSVExporter struct{}

  func (e *CSVExporter) Export(ctx context.Context, data ExportData) (*ExportOutput, error) {
      file, err := os.Create(data.OutputPath)
      if err != nil {
          return nil, err
      }
      defer file.Close()
      
      writer := csv.NewWriter(file)
      defer writer.Flush()
      
      // Convert tasks to CSV format
      tasks := data.Data.([]*entities.Task)
      
      // Write header
      header := []string{"ID", "Title", "Content", "Status", "Priority", "Repository", "Created", "Updated"}
      if data.Options.IncludeMetadata {
          header = append(header, "Metadata")
      }
      if data.Options.IncludeRelations {
          header = append(header, "Dependencies", "Dependents")
      }
      
      if err := writer.Write(header); err != nil {
          return nil, err
      }
      
      // Write data rows
      for _, task := range tasks {
          row := []string{
              task.ID,
              task.Title,
              task.Content,
              task.Status,
              task.Priority,
              task.Repository,
              task.CreatedAt.Format(data.Options.DateFormat),
              task.UpdatedAt.Format(data.Options.DateFormat),
          }
          
          if data.Options.IncludeMetadata {
              metadataJSON, _ := json.Marshal(task.Metadata)
              row = append(row, string(metadataJSON))
          }
          
          if data.Options.IncludeRelations {
              dependencies := strings.Join(task.Dependencies, ";")
              dependents := strings.Join(task.Dependents, ";")
              row = append(row, dependencies, dependents)
          }
          
          if err := writer.Write(row); err != nil {
              return nil, err
          }
      }
      
      // Calculate file info
      fileInfo, err := file.Stat()
      if err != nil {
          return nil, err
      }
      
      // Generate checksums
      checksums := make(map[string]string)
      if data.Options.IncludeMetadata {
          md5Sum, sha256Sum, err := e.generateChecksums(data.OutputPath)
          if err == nil {
              checksums["md5"] = md5Sum
              checksums["sha256"] = sha256Sum
          }
      }
      
      return &ExportOutput{
          OutputPath: data.OutputPath,
          Size:       fileInfo.Size(),
          Checksums:  checksums,
      }, nil
  }

  // Integration implementations
  type Integration interface {
      GetName() string
      Authenticate(ctx context.Context, credentials map[string]string) error
      Export(ctx context.Context, data interface{}, options map[string]interface{}) error
      Import(ctx context.Context, options map[string]interface{}) (interface{}, error)
      GetCapabilities() IntegrationCapabilities
  }

  type GitHubIntegration struct {
      client   *github.Client
      config   GitHubConfig
      logger   *slog.Logger
  }

  func (g *GitHubIntegration) Export(ctx context.Context, data interface{}, options map[string]interface{}) error {
      tasks := data.([]*entities.Task)
      
      repoOwner := options["owner"].(string)
      repoName := options["repository"].(string)
      
      for _, task := range tasks {
          // Create GitHub issue from task
          issue := &github.IssueRequest{
              Title: &task.Title,
              Body:  &task.Content,
          }
          
          // Map priority to labels
          labels := []string{}
          switch task.Priority {
          case "high":
              labels = append(labels, "priority:high")
          case "medium":
              labels = append(labels, "priority:medium")
          case "low":
              labels = append(labels, "priority:low")
          }
          
          // Map status to labels
          switch task.Status {
          case "in_progress":
              labels = append(labels, "status:in-progress")
          case "completed":
              labels = append(labels, "status:completed")
          }
          
          if len(labels) > 0 {
              issue.Labels = &labels
          }
          
          // Create issue
          _, _, err := g.client.Issues.Create(ctx, repoOwner, repoName, issue)
          if err != nil {
              return fmt.Errorf("failed to create issue for task %s: %w", task.ID, err)
          }
      }
      
      return nil
  }

  // Export CLI command
  func NewExportCommand(deps CommandDeps) *cobra.Command {
      cmd := &cobra.Command{
          Use:   "export [format] [filters...]",
          Short: "Export tasks and data in various formats",
          Long: `Export your tasks, projects, and analytics in multiple formats.

Supported formats:
  - json: JSON format for programmatic use
  - csv: Comma-separated values for spreadsheets
  - excel: Microsoft Excel format with formatting
  - pdf: Formatted PDF report
  - markdown: Markdown format for documentation
  - html: HTML format for web viewing
  - gantt: Gantt chart visualization
  - kanban: Kanban board layout

Examples:
  # Export all tasks as CSV
  lmmc export csv --repository myproject

  # Export high priority tasks as PDF
  lmmc export pdf --filter priority=high

  # Export with custom template
  lmmc export excel --template weekly-report

  # Export to specific file
  lmmc export json --output tasks-backup.json

  # Export with metadata and relations
  lmmc export csv --include-metadata --include-relations

  # Schedule weekly export
  lmmc export csv --schedule "weekly" --output-dir /exports`,
          ValidArgs: []string{"json", "csv", "excel", "pdf", "markdown", "html", "gantt", "kanban"},
          RunE: func(cmd *cobra.Command, args []string) error {
              ctx := cmd.Context()
              
              if len(args) == 0 {
                  return fmt.Errorf("export format is required")
              }
              
              format := ExportFormat(args[0])
              
              // Get export options from flags
              repository, _ := cmd.Flags().GetString("repository")
              output, _ := cmd.Flags().GetString("output")
              templateID, _ := cmd.Flags().GetString("template")
              includeMetadata, _ := cmd.Flags().GetBool("include-metadata")
              includeRelations, _ := cmd.Flags().GetBool("include-relations")
              compress, _ := cmd.Flags().GetBool("compress")
              passwordProtect, _ := cmd.Flags().GetBool("password-protect")
              
              // Build filters from remaining args
              filters := make(map[string]interface{})
              for i := 1; i < len(args); i++ {
                  if strings.Contains(args[i], "=") {
                      parts := strings.SplitN(args[i], "=", 2)
                      filters[parts[0]] = parts[1]
                  }
              }
              
              // Additional filters from flags
              if filterFlag, _ := cmd.Flags().GetStringSlice("filter"); len(filterFlag) > 0 {
                  for _, filter := range filterFlag {
                      if strings.Contains(filter, "=") {
                          parts := strings.SplitN(filter, "=", 2)
                          filters[parts[0]] = parts[1]
                      }
                  }
              }
              
              // Build export request
              request := ExportRequest{
                  Repository: repository,
                  Format:     format,
                  Filters:    filters,
                  TemplateID: templateID,
                  OutputPath: output,
                  Options: ExportOptions{
                      IncludeMetadata:  includeMetadata,
                      IncludeRelations: includeRelations,
                      CompressOutput:   compress,
                      PasswordProtect:  passwordProtect,
                      DateFormat:       "2006-01-02 15:04:05",
                      Timezone:         "UTC",
                  },
              }
              
              // Execute export
              fmt.Printf("Exporting tasks as %s...\n", format)
              result, err := deps.ExportService.ExportTasks(ctx, request)
              if err != nil {
                  return err
              }
              
              // Display result
              if result.Status == ExportStatusCompleted {
                  fmt.Printf("✅ Export completed successfully\n")
                  fmt.Printf("   Output: %s\n", result.OutputPath)
                  fmt.Printf("   Records: %d\n", result.RecordCount)
                  fmt.Printf("   Size: %s\n", formatBytes(result.OutputSize))
                  fmt.Printf("   Duration: %v\n", result.Duration)
                  
                  if result.DownloadURL != "" {
                      fmt.Printf("   Download: %s\n", result.DownloadURL)
                  }
                  
                  if result.ExpiresAt != nil {
                      fmt.Printf("   Expires: %s\n", result.ExpiresAt.Format("2006-01-02 15:04:05"))
                  }
              } else {
                  return fmt.Errorf("export failed: %s", result.Error)
              }
              
              return nil
          },
      }
      
      cmd.Flags().StringP("repository", "r", "", "Repository to export from")
      cmd.Flags().StringP("output", "o", "", "Output file path")
      cmd.Flags().StringP("template", "t", "", "Export template to use")
      cmd.Flags().StringSliceP("filter", "f", []string{}, "Filters to apply")
      cmd.Flags().Bool("include-metadata", false, "Include task metadata")
      cmd.Flags().Bool("include-relations", false, "Include task relationships")
      cmd.Flags().Bool("compress", false, "Compress output file")
      cmd.Flags().Bool("password-protect", false, "Password protect output")
      cmd.Flags().String("schedule", "", "Schedule export (daily, weekly, monthly)")
      cmd.Flags().String("integration", "", "Export to integration (github, jira, notion)")
      
      return cmd
  }
  ```

- **Configuration Changes:** 
  - Add export format configurations
  - Configure integration credentials
  - Set export retention policies
  - Add scheduled export settings

- **Dependencies:**
  - Export format libraries (CSV, Excel, PDF generators)
  - Third-party API clients (GitHub, Jira, etc.)
  - Template processing engines

## 4. Acceptance Criteria
- **Functional Criteria:**
  - All export formats produce valid output
  - Third-party integrations work correctly
  - Export templates customize output properly
  - Scheduled exports execute reliably
  - Large datasets export without memory issues
  - Password protection and security work
  - Export history is maintained
  
- **Technical Criteria:**
  - Export completes in reasonable time (<30s for 10k records)
  - Output files are valid and properly formatted
  - Memory usage stays reasonable during export
  - Error handling is robust and informative
  
- **Integration Criteria:**
  - Works with all existing data types
  - Integrates with external services
  - Compatible with scheduled task system
  
- **Test Criteria:**
  - Export output validation for all formats
  - Integration testing with external APIs
  - Performance testing with large datasets
  - Security testing for protected exports

## 5. Testing Requirements
- **Unit Tests:**
  - Export format generation
  - Template processing
  - Filter application
  - Integration API calls
  - Security and validation
  - Error handling
  
- **Integration Tests:**
  - Full export workflows
  - Third-party service integration
  - Scheduled export execution
  - Large dataset handling
  
- **Manual Testing:**
  - Export quality validation
  - Integration functionality
  - User experience testing
  - Performance validation
  
- **Test Data:**
  - Large datasets for performance testing
  - Various data types and structures
  - Integration test accounts
  - Template test scenarios

## 6. Definition of Done
- **Code Complete:** Export and integration system fully implemented
- **Tests Passing:** All export tests passing (≥85% coverage)
- **Documentation Updated:** Export formats and integration guide created
- **Integration Verified:** All integrations tested and functional
- **Review Approved:** Security review of export system completed

## 7. Dependencies and Blockers
- **Required Sub-Tasks:** None (can work with existing data)
- **External Dependencies:** Third-party API access, export libraries
- **Environmental Requirements:** External service credentials for testing
- **Potential Blockers:** Third-party API rate limits or changes

## 8. Integration Notes
- **Component Interfaces:** Used by CLI export commands and scheduling system
- **Data Flow:** Data → Filters → Templates → Export → Storage/Integration
- **Error Handling:** Robust handling of network and API failures
- **Configuration Impact:** New export and integration configuration sections