# ST-MT-002-003: Implement Document and Task Generation Engine with Complexity Analysis

## 1. Sub-Task Overview
- **Sub-Task ID:** ST-MT-002-003
- **Sub-Task Name:** Implement Document and Task Generation Engine with Complexity Analysis
- **Parent Task:** MT-002: AI-Powered Development Automation with Document Generation
- **Estimated Duration:** 5 hours
- **Implementation Type:** Code

## 2. Deliverable Specification
- **Primary Output:** Document and task generation engine that creates main tasks and sub-tasks from TRDs
- **Code Location:** 
  - `cli/internal/domain/services/task_generator.go` - Main/sub-task generation
  - `cli/internal/domain/services/complexity_analyzer.go` - Complexity analysis
  - `cli/internal/domain/services/document_chain.go` - Document chain orchestration
- **Technical Requirements:** Document chain processing, task creation logic, complexity algorithms, dependency detection, validation
- **Interface Definition:** TaskGenerator, DocumentChain, and ComplexityAnalyzer interfaces with business logic

## 3. Implementation Details
- **Step-by-Step Approach:**
  1. Create document chain orchestration service
  2. Implement main task generation from TRDs
  3. Implement sub-task generation from main tasks
  4. Create task generation service interfaces
  5. Implement complexity analysis algorithms
  6. Create task template system for common patterns
  7. Implement dependency detection and mapping
  8. Create effort estimation algorithms
  9. Implement task validation and sanitization
  10. Add task relationship detection

- **Code Examples:**
  ```go
  // Document chain orchestration interface
  type DocumentChain interface {
      // Complete automation chain
      ExecuteFullChain(initialInput string) (*ChainResult, error)
      
      // Individual steps
      GeneratePRDInteractive(context *GenerationContext) (*PRD, error)
      GenerateTRDFromPRD(prd *PRD) (*TRD, error)
      GenerateMainTasksFromTRD(trd *TRD) ([]*MainTask, error)
      GenerateSubTasksFromMain(mainTask *MainTask) ([]*SubTask, error)
      
      // Progress tracking
      GetChainProgress(chainID string) (*ChainProgress, error)
  }
  
  type ChainResult struct {
      ID        string      `json:"id"`
      PRD       *PRD        `json:"prd"`
      TRD       *TRD        `json:"trd"`
      MainTasks []*MainTask `json:"main_tasks"`
      SubTasks  []*SubTask  `json:"sub_tasks"`
      Metadata  ChainMetadata `json:"metadata"`
  }
  
  type MainTask struct {
      ID               string         `json:"id"`
      Name             string         `json:"name"`
      Description      string         `json:"description"`
      Phase            string         `json:"phase"`
      Duration         string         `json:"duration"`
      AtomicValidation bool           `json:"atomic_validation"`
      Dependencies     []string       `json:"dependencies"`
      SubTaskCount     int            `json:"sub_task_count"`
      Content          string         `json:"content"`
      CreatedAt        time.Time      `json:"created_at"`
  }
  
  type SubTask struct {
      ID             string    `json:"id"`
      ParentTaskID   string    `json:"parent_task_id"`
      Name           string    `json:"name"`
      Duration       int       `json:"duration_hours"`
      Type           string    `json:"implementation_type"`
      Deliverables   []string  `json:"deliverables"`
      AcceptanceCriteria []string `json:"acceptance_criteria"`
      Dependencies   []string  `json:"dependencies"`
      Content        string    `json:"content"`
      CreatedAt      time.Time `json:"created_at"`
  }
  
  // Enhanced task generation service interface
  type TaskGenerator interface {
      GenerateFromAnalysis(analysis *AIAnalysis, context GenerationContext) ([]*Task, error)
      GenerateMainTasks(trd *TRD, rule *Rule) ([]*MainTask, error)
      GenerateSubTasks(mainTask *MainTask, rule *Rule) ([]*SubTask, error)
      AnalyzeComplexity(content string) (*ComplexityAnalysis, error)
      ValidateGeneration(tasks interface{}) error
  }
  
  type GenerationContext struct {
      Repository     string            `json:"repository"`
      ProjectType    string            `json:"project_type"`
      ExistingTasks  []*Task           `json:"existing_tasks"`
      Templates      []*TaskTemplate   `json:"templates"`
      UserPrefs      UserPreferences   `json:"user_preferences"`
  }
  
  type ComplexityAnalysis struct {
      Score          float64          `json:"score"`           // 0-10
      Level          string           `json:"level"`           // low, medium, high
      Factors        []ComplexityFactor `json:"factors"`
      EstimatedHours int              `json:"estimated_hours"`
      Confidence     float64          `json:"confidence"`      // 0-1
      Breakdown      ComplexityBreakdown `json:"breakdown"`
      Recommendations []string        `json:"recommendations"`
  }
  
  type ComplexityFactor struct {
      Name        string  `json:"name"`
      Impact      string  `json:"impact"`        // low, medium, high
      Score       float64 `json:"score"`
      Description string  `json:"description"`
  }
  
  type ComplexityBreakdown struct {
      Technical    float64 `json:"technical"`     // 0-10
      Business     float64 `json:"business"`      // 0-10
      Integration  float64 `json:"integration"`   // 0-10
      Testing      float64 `json:"testing"`       // 0-10
      Documentation float64 `json:"documentation"` // 0-10
  }
  
  type TaskTemplate struct {
      ID          string   `json:"id"`
      Name        string   `json:"name"`
      Type        string   `json:"type"`
      Pattern     string   `json:"pattern"`
      Keywords    []string `json:"keywords"`
      Complexity  string   `json:"complexity"`
      Hours       int      `json:"estimated_hours"`
      SubTasks    []string `json:"subtask_templates"`
  }
  
  // Task generator implementation
  type DefaultTaskGenerator struct {
      complexityAnalyzer ComplexityAnalyzer
      templateMatcher    TemplateMatcher
      dependencyDetector DependencyDetector
      logger            *slog.Logger
      config            *GeneratorConfig
  }
  
  type GeneratorConfig struct {
      MaxTasksPerPRD    int     `mapstructure:"max_tasks_per_prd"`
      ComplexityThreshold float64 `mapstructure:"complexity_threshold"`
      MinTaskHours      int     `mapstructure:"min_task_hours"`
      MaxTaskHours      int     `mapstructure:"max_task_hours"`
      AutoSubTasking    bool    `mapstructure:"auto_subtasking"`
  }
  
  func NewDefaultTaskGenerator(config *GeneratorConfig, logger *slog.Logger) *DefaultTaskGenerator {
      return &DefaultTaskGenerator{
          complexityAnalyzer: NewComplexityAnalyzer(),
          templateMatcher:    NewTemplateMatcher(),
          dependencyDetector: NewDependencyDetector(),
          logger:            logger,
          config:            config,
      }
  }
  
  // Document chain implementation
  type DefaultDocumentChain struct {
      aiService       AIService
      taskGenerator   TaskGenerator
      ruleManager     RuleManager
      documentStore   DocumentStore
      logger          *slog.Logger
  }
  
  func NewDefaultDocumentChain(aiService AIService, taskGenerator TaskGenerator, ruleManager RuleManager, store DocumentStore, logger *slog.Logger) *DefaultDocumentChain {
      return &DefaultDocumentChain{
          aiService:     aiService,
          taskGenerator: taskGenerator,
          ruleManager:   ruleManager,
          documentStore: store,
          logger:        logger,
      }
  }
  
  func (c *DefaultDocumentChain) ExecuteFullChain(initialInput string) (*ChainResult, error) {
      chainID := uuid.New().String()
      c.logger.Info("starting document chain execution", slog.String("chain_id", chainID))
      
      // Create generation context
      context := &GenerationContext{
          Type:       DocumentTypePRD,
          UserInputs: []string{initialInput},
          Repository: c.detectRepository(),
      }
      
      // Step 1: Generate PRD interactively
      prd, err := c.GeneratePRDInteractive(context)
      if err != nil {
          return nil, fmt.Errorf("PRD generation failed: %w", err)
      }
      
      // Step 2: Generate TRD from PRD
      trd, err := c.GenerateTRDFromPRD(prd)
      if err != nil {
          return nil, fmt.Errorf("TRD generation failed: %w", err)
      }
      
      // Step 3: Generate main tasks from TRD
      mainTasks, err := c.GenerateMainTasksFromTRD(trd)
      if err != nil {
          return nil, fmt.Errorf("main task generation failed: %w", err)
      }
      
      // Step 4: Generate sub-tasks for each main task
      var allSubTasks []*SubTask
      for _, mainTask := range mainTasks {
          subTasks, err := c.GenerateSubTasksFromMain(mainTask)
          if err != nil {
              c.logger.Warn("sub-task generation failed for main task",
                  slog.String("main_task", mainTask.ID),
                  slog.Any("error", err))
              continue
          }
          allSubTasks = append(allSubTasks, subTasks...)
      }
      
      result := &ChainResult{
          ID:        chainID,
          PRD:       prd,
          TRD:       trd,
          MainTasks: mainTasks,
          SubTasks:  allSubTasks,
          Metadata: ChainMetadata{
              StartTime:    time.Now(),
              Repository:   context.Repository,
              TotalTasks:   len(mainTasks) + len(allSubTasks),
          },
      }
      
      return result, nil
  }
  
  func (c *DefaultDocumentChain) GenerateMainTasksFromTRD(trd *TRD) ([]*MainTask, error) {
      // Get main task generation rule
      rule, err := c.ruleManager.GetRule(RuleTypeMainTasks)
      if err != nil {
          return nil, fmt.Errorf("failed to get main tasks rule: %w", err)
      }
      
      // Use AI to generate main tasks
      mainTasks, err := c.aiService.GenerateMainTasks(trd, rule)
      if err != nil {
          return nil, fmt.Errorf("AI main task generation failed: %w", err)
      }
      
      // Validate and enhance main tasks
      for i, task := range mainTasks {
          task.ID = fmt.Sprintf("MT-%03d", i+1)
          task.AtomicValidation = c.validateAtomicTask(task)
          
          // Analyze complexity for duration estimate
          complexity, _ := c.taskGenerator.AnalyzeComplexity(task.Content)
          if complexity != nil {
              task.Duration = c.estimateTaskDuration(complexity)
          }
      }
      
      // Detect dependencies between main tasks
      c.detectMainTaskDependencies(mainTasks)
      
      return mainTasks, nil
  }
  
  func (c *DefaultDocumentChain) GenerateSubTasksFromMain(mainTask *MainTask) ([]*SubTask, error) {
      // Get sub-task generation rule
      rule, err := c.ruleManager.GetRule(RuleTypeSubTasks)
      if err != nil {
          return nil, fmt.Errorf("failed to get sub-tasks rule: %w", err)
      }
      
      // Use task generator to create sub-tasks
      subTasks, err := c.taskGenerator.GenerateSubTasks(mainTask, rule)
      if err != nil {
          return nil, fmt.Errorf("sub-task generation failed: %w", err)
      }
      
      // Enhance sub-tasks with IDs and relationships
      for i, subTask := range subTasks {
          subTask.ID = fmt.Sprintf("ST-%s-%03d", mainTask.ID, i+1)
          subTask.ParentTaskID = mainTask.ID
          
          // Ensure duration is within 2-4 hour range
          if subTask.Duration < 2 {
              subTask.Duration = 2
          } else if subTask.Duration > 4 {
              subTask.Duration = 4
          }
      }
      
      return subTasks, nil
  }
  
  func (g *DefaultTaskGenerator) GenerateFromAnalysis(analysis *AIAnalysis, context GenerationContext) ([]*Task, error) {
      var tasks []*Task
      
      // Process each key feature from AI analysis
      for _, feature := range analysis.KeyFeatures {
          task, err := g.createTaskFromFeature(feature, analysis, context)
          if err != nil {
              g.logger.Warn("failed to create task from feature",
                  slog.String("feature", feature),
                  slog.Any("error", err))
              continue
          }
          
          tasks = append(tasks, task)
          
          // Generate sub-tasks if complexity is high
          if g.config.AutoSubTasking && task.EstimatedHours > g.config.MaxTaskHours {
              subTasks, err := g.GenerateSubTasks(task)
              if err != nil {
                  g.logger.Warn("failed to generate sub-tasks",
                      slog.String("task", task.Content),
                      slog.Any("error", err))
              } else {
                  tasks = append(tasks, subTasks...)
              }
          }
      }
      
      // Process technical requirements
      for _, techReq := range analysis.TechnicalReqs {
          task, err := g.createTaskFromTechnicalReq(techReq, analysis, context)
          if err != nil {
              g.logger.Warn("failed to create task from technical requirement",
                  slog.String("requirement", techReq),
                  slog.Any("error", err))
              continue
          }
          
          tasks = append(tasks, task)
      }
      
      // Detect and set dependencies
      g.detectTaskDependencies(tasks)
      
      // Validate generation results
      if err := g.ValidateGeneration(tasks); err != nil {
          return nil, fmt.Errorf("task generation validation failed: %w", err)
      }
      
      g.logger.Info("generated tasks from PRD analysis",
          slog.Int("task_count", len(tasks)),
          slog.String("prd_id", analysis.PRDID))
      
      return tasks, nil
  }
  
  func (g *DefaultTaskGenerator) createTaskFromFeature(feature string, analysis *AIAnalysis, context GenerationContext) (*Task, error) {
      // Match with templates
      template := g.templateMatcher.FindBestMatch(feature, context.ProjectType)
      
      // Analyze complexity
      complexity, err := g.complexityAnalyzer.AnalyzeContent(feature)
      if err != nil {
          return nil, fmt.Errorf("complexity analysis failed: %w", err)
      }
      
      // Generate task content
      content := g.generateTaskContent(feature, template, complexity)
      
      // Create task entity
      task := &Task{
          ID:             uuid.New().String(),
          Content:        content,
          Status:         StatusPending,
          Priority:       g.determinePriority(complexity, template),
          Repository:     context.Repository,
          Tags:           g.generateTags(feature, template, complexity),
          EstimatedHours: complexity.EstimatedHours,
          CreatedAt:      time.Now(),
          UpdatedAt:      time.Now(),
          Metadata: map[string]interface{}{
              "source":     "ai_generated",
              "prd_id":     analysis.PRDID,
              "feature":    feature,
              "template":   template.ID,
              "complexity": complexity.Level,
              "confidence": complexity.Confidence,
          },
      }
      
      return task, nil
  }
  
  // Complexity analyzer implementation
  type ComplexityAnalyzer interface {
      AnalyzeContent(content string) (*ComplexityAnalysis, error)
      AnalyzeTask(task *Task) (*ComplexityAnalysis, error)
      EstimateEffort(complexity *ComplexityAnalysis) int
  }
  
  type DefaultComplexityAnalyzer struct {
      patterns map[string]ComplexityPattern
      weights  ComplexityWeights
  }
  
  type ComplexityPattern struct {
      Keywords    []string `json:"keywords"`
      Impact      float64  `json:"impact"`
      Category    string   `json:"category"`
      Description string   `json:"description"`
  }
  
  type ComplexityWeights struct {
      Technical     float64 `json:"technical"`
      Business      float64 `json:"business"`
      Integration   float64 `json:"integration"`
      Testing       float64 `json:"testing"`
      Documentation float64 `json:"documentation"`
  }
  
  func NewComplexityAnalyzer() *DefaultComplexityAnalyzer {
      return &DefaultComplexityAnalyzer{
          patterns: loadComplexityPatterns(),
          weights:  getDefaultWeights(),
      }
  }
  
  func (a *DefaultComplexityAnalyzer) AnalyzeContent(content string) (*ComplexityAnalysis, error) {
      content = strings.ToLower(content)
      words := strings.Fields(content)
      
      var factors []ComplexityFactor
      breakdown := ComplexityBreakdown{}
      
      // Analyze technical complexity
      technicalScore := a.analyzeTechnicalComplexity(content, words)
      breakdown.Technical = technicalScore
      
      if technicalScore > 5.0 {
          factors = append(factors, ComplexityFactor{
              Name:        "Technical Complexity",
              Impact:      "high",
              Score:       technicalScore,
              Description: "High technical implementation complexity detected",
          })
      }
      
      // Analyze business complexity
      businessScore := a.analyzeBusinessComplexity(content, words)
      breakdown.Business = businessScore
      
      // Analyze integration complexity
      integrationScore := a.analyzeIntegrationComplexity(content, words)
      breakdown.Integration = integrationScore
      
      // Analyze testing complexity
      testingScore := a.analyzeTestingComplexity(content, words)
      breakdown.Testing = testingScore
      
      // Analyze documentation complexity
      docScore := a.analyzeDocumentationComplexity(content, words)
      breakdown.Documentation = docScore
      
      // Calculate overall score
      overallScore := (technicalScore*a.weights.Technical +
          businessScore*a.weights.Business +
          integrationScore*a.weights.Integration +
          testingScore*a.weights.Testing +
          docScore*a.weights.Documentation) / 5.0
      
      level := a.scoreToLevel(overallScore)
      estimatedHours := a.scoreToHours(overallScore)
      confidence := a.calculateConfidence(factors, len(words))
      
      return &ComplexityAnalysis{
          Score:          overallScore,
          Level:          level,
          Factors:        factors,
          EstimatedHours: estimatedHours,
          Confidence:     confidence,
          Breakdown:      breakdown,
          Recommendations: a.generateRecommendations(breakdown, factors),
      }, nil
  }
  
  func (a *DefaultComplexityAnalyzer) analyzeTechnicalComplexity(content string, words []string) float64 {
      score := 0.0
      
      // Check for complex technical patterns
      complexPatterns := []string{
          "api", "database", "authentication", "authorization", "security",
          "integration", "microservice", "architecture", "performance",
          "algorithm", "optimization", "concurrent", "distributed",
      }
      
      for _, pattern := range complexPatterns {
          if strings.Contains(content, pattern) {
              score += 1.0
          }
      }
      
      // Length-based complexity
      if len(words) > 50 {
          score += 1.0
      }
      if len(words) > 100 {
          score += 1.0
      }
      
      // Cap at 10.0
      if score > 10.0 {
          score = 10.0
      }
      
      return score
  }
  
  func (a *DefaultComplexityAnalyzer) scoreToLevel(score float64) string {
      switch {
      case score >= 7.0:
          return "high"
      case score >= 4.0:
          return "medium"
      default:
          return "low"
      }
  }
  
  func (a *DefaultComplexityAnalyzer) scoreToHours(score float64) int {
      // Base hours + complexity multiplier
      baseHours := 2
      complexityMultiplier := int(score * 0.5)
      
      hours := baseHours + complexityMultiplier
      
      // Ensure reasonable bounds
      if hours < 1 {
          hours = 1
      }
      if hours > 40 {
          hours = 40
      }
      
      return hours
  }
  ```

- **Configuration Changes:** Adds task generation configuration options
- **Dependencies:**
  - String processing and pattern matching
  - UUID generation for task IDs
  - JSON handling for templates

## 4. Acceptance Criteria
- **Functional Criteria:**
  - Document chain executes complete PRD → TRD → Main Tasks → Sub-tasks flow
  - Main task generation creates atomic, deployable phases from TRDs
  - Sub-task generation creates 2-4 hour implementable tasks
  - Task generator creates relevant tasks from AI analysis
  - Complexity analysis provides accurate effort estimates
  - Template matching improves task quality and consistency
  - Dependency detection identifies task relationships correctly
  - Each step in the chain can be executed independently
  
- **Technical Criteria:**
  - Document chain maintains state throughout execution
  - Generation algorithms handle edge cases gracefully
  - Main tasks follow atomic validation principles
  - Sub-tasks adhere to duration constraints
  - Complexity scoring is consistent and explainable
  - Task validation prevents invalid or duplicate tasks
  - Performance is acceptable for large documents
  
- **Integration Criteria:**
  - Document chain integrates with AI service and rule manager
  - Generated tasks follow expected document formats
  - Main/sub-task hierarchy is properly maintained
  - Templates support common project patterns
  - Complexity analysis integrates with effort tracking
  
- **Test Criteria:**
  - Complete chain execution tested end-to-end
  - Individual chain steps tested in isolation
  - All generation scenarios tested with various inputs
  - Complexity algorithms validated with known cases
  - Template matching accuracy verified

## 5. Testing Requirements
- **Unit Tests:**
  - Document chain orchestration logic
  - Main task generation from TRD content
  - Sub-task generation with duration constraints
  - Task generation from various AI analysis inputs
  - Complexity analysis algorithm accuracy
  - Template matching for different project types
  - Atomic task validation logic
  - Dependency detection correctness
  - Task validation rules and edge cases
  - Effort estimation algorithm consistency

- **Integration Tests:**
  - Complete document chain execution (PRD → Sub-tasks)
  - Individual chain step execution and resumption
  - Main/sub-task hierarchy maintenance
  - Rule integration for task generation
  - Template system with real project scenarios
  - Complexity analysis with historical data validation
  
- **Manual Testing:**
  - Document chain quality assessment
  - Main task atomic validation accuracy
  - Sub-task implementability review
  - Generation quality with real documents
  - User acceptance of generated task quality
  - Complexity estimates vs actual effort validation
  
- **Test Data:** Sample TRDs, main task examples, complexity scenarios, project templates

## 6. Definition of Done
- **Code Complete:** Document chain and task generation engine fully implemented
- **Tests Passing:** All chain and generation scenarios tested (≥85% coverage)
- **Documentation Updated:** Chain workflow, generation algorithms, and templates documented
- **Integration Verified:** Works with AI service, rules, and document entities
- **Review Approved:** Chain logic, atomic validation, and business rules review

## 7. Dependencies and Blockers
- **Required Sub-Tasks:** ST-MT-002-002 (AI Service Layer) and ST-MT-002-001 (Document Entities)
- **External Dependencies:** Task templates, complexity patterns, rule templates
- **Environmental Requirements:** None specific
- **Potential Blockers:** Chain orchestration complexity, atomic validation rules, template quality

## 8. Integration Notes
- **Component Interfaces:** Used by CLI commands and workflow automation
- **Data Flow:** 
  - Chain: PRD → TRD → Main Tasks → Sub-tasks
  - Generation: Document/Analysis → Task Engine → Structured Tasks
- **Error Handling:** Graceful degradation with partial generation results, chain resumption
- **Configuration Impact:** Chain configuration, template settings, generation parameters